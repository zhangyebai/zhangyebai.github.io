{"meta":{"title":"一码平川","subtitle":null,"description":null,"author":"张夜白","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2019-02-12T09:26:15.000Z","updated":"2019-02-12T09:30:58.238Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-02-12T09:26:01.000Z","updated":"2019-02-12T09:30:44.034Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode - 002 - Add Two Numbers (Medium) [Java,Python,C++]","slug":"add-two-numbers","date":"2017-02-19T07:08:44.000Z","updated":"2019-02-12T09:45:23.006Z","comments":true,"path":"2017/02/19/add-two-numbers/","link":"","permalink":"http://yoursite.com/2017/02/19/add-two-numbers/","excerpt":"Descripiton You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。 这句话什么意思呢？换句话说就是这样： 比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4); 19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1); 因为表示顺序是反着的，所以进位也是反着的。 假设这两个数字不包含任何的头结点0，除了数字0本身。 Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8","text":"Descripiton You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。 这句话什么意思呢？换句话说就是这样： 比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4); 19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1); 因为表示顺序是反着的，所以进位也是反着的。 假设这两个数字不包含任何的头结点0，除了数字0本身。 Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Solution 通过描述中的大致分析可以看出，需要遍历两个Linked-List中的对应的Node并取数相加，然后生成新Node并添加到result的Link-List中。 - 2个Linked-List中对应的Node，如果有一个为null，一个不为null，则结果节点直接使用不为null的Node中的值去构造即可; - 如果两个Node相加需要进位，切记是向后进位，如果有后续Node，计算是需要加上进位; - 如果两个Node相加需要进位，且没有后续Node，则需要添加一个Node，值用进位的数即可; - 以下代码截止到提交日期，均已被LeetCode AC； Python Solution code #!/usr/bin/env python # _*_ coding:utf-8 _*_ #Node定义 class ListNode(object): def __init__(self, x): self.val = x self.next = None #LeetCode的命名规范我已经无力吐槽了 class Solution(object): def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode: \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" result = ListNode(0) step = result l_hand, r_hand = l1, l2 node_sum = 0 while l_hand is not None or r_hand is not None: node_sum //= 10 if l_hand is not None: node_sum += l_hand.val l_hand = l_hand.next if r_hand is not None: node_sum += r_hand.val r_hand = r_hand.next step.next = ListNode(node_sum % 10) step = step.next if node_sum // 10 > 0: step.next = ListNode(1) return result.next #TestCase def init_node(param)->ListNode: result_node, temp_node = None, None for value in param: if result_node is None: temp_node = ListNode(value) result_node = temp_node continue temp_node.next = ListNode(value) temp_node = temp_node.next return result_node def print_node(param_node: ListNode)->None: temp_node, values = param_node, [] while temp_node is not None: values.append(str(temp_node.val)) temp_node = temp_node.next print('[', '->'.join(values), ']', sep=None) if __name__ == '__main__': l_node = init_node([3, 7]) r_node = init_node([9, 2]) print_node(Solution().add_two_nums(l_node, r_node)) Java Solution code public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode result = new ListNode(0); ListNode step = result; ListNode l_hand = l1; ListNode r_hand = l2; int node_sum = 0; for(;l_hand != null || r_hand != null;){ node_sum /= 10; if (l_hand != null){ node_sum += l_hand.val; l_hand = l_hand.next; } if (r_hand !=null){ node_sum += r_hand.val; r_hand = r_hand.next; } step.next = new ListNode(node_sum % 10); step = step.next; } if (node_sum / 10 > 0){ step.next = new ListNode(1); } return result.next; } //TestCase public static void printNode(ListNode node){ while (node != null){ System.out.println(node.val); node = node.next; } } public static void main(String[] args){ //不要问我这两个数组时哪里来的，没有错误的程序是不会知道的 int[] arr1 = {1,6,6,0,5,8,1,0,7}; int[] arr2 = {8,2,5,7,9,1,0,2,2,1}; printNode(new AddTwoNumbers().addTwoNumbers(initList(arr1), initList(arr2))); } } class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } C++ Solution code #ifndef NULL #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif #endif struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class AddTwoNumbers { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode head(0); ListNode *step = &head, *l_hand = l1, *r_hand = l2; int node_sum = 0; for (; l_hand || r_hand;) { node_sum /= 10; if (l_hand) { node_sum += l_hand->val; l_hand = l_hand->next; } if (r_hand) { node_sum += r_hand->val; r_hand = r_hand->next; } step->next = new ListNode(node_sum % 10); step = step->next; } if (node_sum / 10 > 0) { step->next = new ListNode(1); } return head.next; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"leetcode,Java,Python,C++","slug":"leetcode-Java-Python-C","permalink":"http://yoursite.com/tags/leetcode-Java-Python-C/"}]},{"title":"Singleton - 单例模式 - Java","slug":"Singleton","date":"2017-02-13T15:48:30.000Z","updated":"2019-02-12T07:44:10.375Z","comments":true,"path":"2017/02/13/Singleton/","link":"","permalink":"http://yoursite.com/2017/02/13/Singleton/","excerpt":"单例模式 One instance of a class or one value accessible globally in an application. Ensure that only one instance of a class is created. Provide a global point of access to the object. 在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点: 确保该唯一实例被创建。 为外界使用该实例提供一个全局的访问入口。 对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。","text":"单例模式 One instance of a class or one value accessible globally in an application. Ensure that only one instance of a class is created. Provide a global point of access to the object. 在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点: 确保该唯一实例被创建。 为外界使用该实例提供一个全局的访问入口。 对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。 简单懒汉式单例模式 - 简单 * 3，但是致命缺点是线程不安全。 - 懒汉式:在Singleton被ClassLoader加载时并不实例化instance，只有在需要时(即调用getInstance方法时)才会触发实例化。 - getInstance，newInstance在命名规范上的区别是分别对应单例和多例! code public class Singleton implements java.io.Serializable { private static Singleton instance; private Singleton(){ } public static Singleton getSingletonInstance(){ if (instance == null){ instance = new Singleton(); } return instance; } private Object readResolve(){ return instance; } } //RuntimeTestCase 10000000次 3ms public static void testRuntime(){ long timestart = System.currentTimeMillis(); for (int index = 0, loop = 10000000; index < loop; ++index){ Singleton singletonThread1 = Singleton.getSingletonInstance(); } } long timeend = System.currentTimeMillis(); System.out.println(timeend - timestart); } //MultipleInstanceTestCase class MultipleTest implements Runnable{ public Map hMap = new Hashtable(); @Override public void run() { Singleton singleton = Singleton.getSingletonInstance(); hMap.put(singleton, 0); } } /*开启了100000个线程测试，并未发现有多个实例的现象，但是此种做法确实是存在多例的风险，原因在于当两个线程同时调用 getSingletonInstance()且instance都为null时，两个线程可能会同时执行instance = new Singleton();*/ 线程安全懒汉式单例模式 - 通过对全局入口方法加同步来解决线程安全的问题。 - 带来的后果是资源的开销是非常大的，因为初始化完instance后不再需要synchronized - 毕竟线程安全了。 code public class Singleton implements java.io.Serializable { private static Singleton instance; private Singleton(){ } public static synchroized Singleton getSingletonInstance(){ if (instance == null){ instance = new Singleton(); } return instance; } private Object readResolve(){ return instance; } } //RuntimeTestCase 10000000次调用 56ms （简单懒汉式单例模式中为3ms） //测试代码参考 简单懒汉式单例模式 中代码 //MultipleInstanceTestCase //参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 改进效率版懒汉式单例模式 - synchroized 同步方法的资源开销是很大的。 - 改进点在于用synchronized同步实例化代码块，这样的好处是一旦实例化完成，以后的调用不会再触碰到synchronized。 code public class Singleton implements java.io.Serializable{ private volatile static Singleton instance; private Singleton(){ } public static Singleton getSingletonInstance(){ if (instance == null){ synchroized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } private Object readResolve(){ return instance; } } //RuntimeTestCase 10000000次调用 3ms 理论上来说应该于 简单懒汉式单例模式 中的实现效率持平。 //测试代码参考 简单懒汉式单例模式 中代码 //MultipleInstanceTestCase //参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 饿汉式单例模式 - 触发ClassLoader加载该类时实例化。 - 与懒汉式的区别是:主动实例化。 code public class Singleton implements java.io.Serializable{ private static Singleton instance = new Singleton(); private Singleton(){ } public static Singleton getSingletonInstance(){ return instance; } private Object readResolve(){ return instance; } } //另一种写法是通过静态代码块实例化 public class Singleton implements java.io.Serializable{ private static Singleton instance; static{ instance = new Singleton(); } private Singleton(){ } public static Singleton getSingletonInstance(){ return instance; } private Object readResolve(){ return instance; } } //RuntimeTestCase 10000000次调用 2ms。 //MultipleInstanceTestCase //参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 静态内部类实现单例 - 实现延迟实例化。 - 线程安全。 - 推荐使用。 code public class Singleton implements java.io.Serializable{ private static class SingletonController{ private static Singleton instance = new Singleton(); } public static Singleton getSingletonInstance(){ return SingletonController.instance; } private Object readResolve(){ return SingletonController.instance;; } } //RuntimeTestCase 10000000次调用 3ms 。 //测试代码参考 简单懒汉式单例模式 中代码 //MultipleInstanceTestCase //参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 枚举实现 最近在看《Effective java 中文版2th》的时候，看到的此种方法，顿时被惊呆。以下为书中原话: - since jdk 1.5 。 - 只需编写一个包含单个元素的枚举类型即可实现。 - 此方法在功能上与公有域方法接近，但是它更加简洁，无偿地提供了序列化机制。 - 绝对的防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。 - 虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。 code public enum Singleton{ INSTANCE; //代码至此已经完事。 }","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://yoursite.com/categories/Design-Pattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://yoursite.com/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"LeetCode - 001 - Two Sum (Easy) [Java,Python,C++]","slug":"two-sum","date":"2017-02-12T21:02:51.000Z","updated":"2019-02-12T07:44:10.395Z","comments":true,"path":"2017/02/13/two-sum/","link":"","permalink":"http://yoursite.com/2017/02/13/two-sum/","excerpt":"Descripiton Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。 假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。 Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Solution 利用map数据结构的Key-Value键值对的存储特点，遍历array数组时，查看当前数组元素value与目标target的差（target - value）是否在map的keys中，如果存在说明前面的遍历时找到了第一个value，取出索引并返回当前索引即可;如果没找到，将当前value作为key，当前索引index作为key的value放置进map继续遍历即可。 Python中map数据结构为字典（dict） 适当关注一下c++中std::map和std::vector的相关操作 以下代码截止到提交日期，均已被LeetCode AC","text":"Descripiton Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。 假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。 Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Solution 利用map数据结构的Key-Value键值对的存储特点，遍历array数组时，查看当前数组元素value与目标target的差（target - value）是否在map的keys中，如果存在说明前面的遍历时找到了第一个value，取出索引并返回当前索引即可;如果没找到，将当前value作为key，当前索引index作为key的value放置进map继续遍历即可。 Python中map数据结构为字典（dict） 适当关注一下c++中std::map和std::vector的相关操作 以下代码截止到提交日期，均已被LeetCode AC Python Solution code #!/usr/bin/env python # _*_ coding:utf-8 _*_ class Solution(object): def two_num(nums, target)->object: nums_dict = {} for loop, value in enumerate(nums): if nums_dict.__contains__(target - value): return [nums_dict[target - value], loop] else: nums_dict[value] = loop #TestCase if __name__ == '__main__': num_list = [2, 7, 11, 15] target_num = 22 result = Solution().two_num(num_list, target_num) try: for index in result: print('->'.join([str(index), str(num_list[index])])) except TypeError: print('no target to find') Java Solution code public class Solution{ public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; Map&ltInteger, Integer> map = new HashMap&ltInteger, Integer>(); for(int index = 0, length = nums.length; index < length; ++index){ if (map.containsKey(target - nums[index])){ result[0] = map.get(target - nums[index]); result[1] = index; }else{ map.put(nums[index], index); } } return result; } } C++ Solution code #include &lt;vector> #include &lt;map> class Solution { public: std::vector twoSum(std::vector& nums, int target) { std::vector result; std::map loop; for (std::size_t index = 0; index < nums.size(); ++index) { if (loop.find(target - nums.at(index)) != loop.cend()) { result.push_back(loop.at(target - nums.at(index))); result.push_back(index); } else { loop.insert(std::map::value_type(nums.at(index), index)); } } return result; } }; //TestCase #include &lt;iostream> int main() { Solution solution; std::vector nums = { 2, 7, 11, 15 }; std::vector result = solution.twoSum(nums, 9); for(std::vector::iterator iter = result.begin(); iter != result.end(); ++iter) std::cout timing; return 0; }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]}