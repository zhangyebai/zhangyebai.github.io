{"meta":{"title":"一码平川","subtitle":null,"description":null,"author":"张夜白","url":"http://www.zhangyebai.com"},"pages":[{"title":"about","date":"2019-02-12T09:52:52.000Z","updated":"2019-02-12T09:58:13.812Z","comments":true,"path":"about/index.html","permalink":"http://www.zhangyebai.com/about/index.html","excerpt":"","text":"张夜白 GitHub 北京 29"},{"title":"categories","date":"2019-02-12T09:26:15.000Z","updated":"2019-02-12T09:30:58.238Z","comments":true,"path":"categories/index.html","permalink":"http://www.zhangyebai.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-02-12T09:26:01.000Z","updated":"2019-02-12T09:30:44.034Z","comments":true,"path":"tags/index.html","permalink":"http://www.zhangyebai.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"手写线程池 modern-cpluscplus-threadpool","slug":"modern-cpluscplus-threadpool","date":"2019-02-14T06:38:00.000Z","updated":"2019-02-14T09:06:47.724Z","comments":true,"path":"2019/02/14/modern-cpluscplus-threadpool/","link":"","permalink":"http://www.zhangyebai.com/2019/02/14/modern-cpluscplus-threadpool/","excerpt":"C++线程池 进程的创建和销毁,代价是昂贵的,除去操作系统的实现及其本身的原理,跟线程相比它更显得重量级。 这几年互联网的迅速发展,让线程正面临着跟进程一样的“重量级”困扰。尤其是GO等语言退出协程(纤程) 后,线程更是不堪其重。那么有没有改进的方向呢？有,将线程池化——线程池。 由于C++版本推进的历程(C++98, C++03, C++11, C++14, C++17, C++20)以及其 弱鸡般的ABI兼容性,导致很多框架用起来得自己造轮子。C++版本再吐槽一句好了, C++即使版本推进到 0xff, 对很多人来说还是c with class, 包括我。 我们的目标是, 造一个很Java中的ThreadPool类似的线程池。目前的进度: [x] 极其简易的线程池(header only) [x] 支持设置线程池核心线程数 [ ] 支持设置线程池最大线程数 [ ] 支持设置最大缓存的任务数 [ ] 支持设置任务提交拒绝策略","text":"C++线程池 进程的创建和销毁,代价是昂贵的,除去操作系统的实现及其本身的原理,跟线程相比它更显得重量级。 这几年互联网的迅速发展,让线程正面临着跟进程一样的“重量级”困扰。尤其是GO等语言退出协程(纤程) 后,线程更是不堪其重。那么有没有改进的方向呢？有,将线程池化——线程池。 由于C++版本推进的历程(C++98, C++03, C++11, C++14, C++17, C++20)以及其 弱鸡般的ABI兼容性,导致很多框架用起来得自己造轮子。C++版本再吐槽一句好了, C++即使版本推进到 0xff, 对很多人来说还是c with class, 包括我。 我们的目标是, 造一个很Java中的ThreadPool类似的线程池。目前的进度: [x] 极其简易的线程池(header only) [x] 支持设置线程池核心线程数 [ ] 支持设置线程池最大线程数 [ ] 支持设置最大缓存的任务数 [ ] 支持设置任务提交拒绝策略 线程池中的概念: job: 需要在线程中执行的代码 例如: void read(const string &amp; path, const HANDLE handle); 该函数从文本中读取内容然后交给窗口渲染到界面上 task: 将job封装成一个task, 由于job的函数签名各异,所以需要封装(Java的job是Runnable,接口签名一致)。 例如: auto task = [=]()-&gt;void { return read(path, handle); } 这样就将签名各异的job统一封装成了std::function&lt;void()&gt;类型的task 通过std::packaged_task和std::future处理job被异步调用的返回值 queue: 缓存task的队列, 队列操作和线程池中的线程耦合度很高, 原因如下: 队列中的任务少时, 池中的空闲线程如何做到真正的不占用cpu? 目前此项目是通过std::condition_variable的条件判断让空闲线程阻塞从而让出cpu Java中是通过实现BlockQueue实现的,也就是队列中没有任务时,线程从队列中get会阻塞, 从而让出cpu 也可以通过信号量 互斥量实现 队列read write操作时, 可根据现实情况实现读优先、写优先的锁来平衡队列task的生产和消费, 目前此项目不支持 设置queue的最大缓存task数 为什么采取队列, 是为了保证task被执行的优先级(队列可以保证先提交的task被先执行,但是不保证先提交的task被先执行完) thread: 采用C++11 标准库中的std::thread 根据std::thread::hardware_concurrency()获取cpu数量进行任务cpu友好性优化, 目前此项目不支持 设置thread的cpu亲和性优化程序执行（Windows平台:通过SetThreadAffinityMask指定线程在cpu哪个核心上运行） Code Code On GitHub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#ifndef _THREAD_POOL_H#define _THREAD_POOL_H#include &lt;memory&gt;#include &lt;functional&gt;#include &lt;future&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;thread&gt;#include &lt;typeinfo&gt;/** * 几个需要注意的点: * 1、tasks的读写锁需要优化成带优先级的锁, 可以肯定线程池的绝大部分使用场景commit task比run task更密集 * 2、根据tasks以及cpu扩展线程数 * 3、支持允许缓存的task数,如果超出此数将采取拒绝策略 * 4、拒绝策略*/class ThreadPool&#123;public: ThreadPool(int core, int max = 0, int cache = 0): core(core),//由于max和cache暂时没用到,因此赋值0 max(max), cache(cache), quit(false), force(false)&#123; &#125; ~ThreadPool()&#123; this-&gt;quit.store(true); this-&gt;enable.notify_all(); std::for_each(this-&gt;pool.begin(), this-&gt;pool.end(), [](std::thread &amp; t)&#123; if(t.joinable())&#123; t.join(); &#125; &#125;); &#125;public: void start()&#123; for(auto idx = 0; idx &lt; core; ++idx)&#123; pool.push_back(std::thread([this]()&#123; // 第一次退出,判断是否要强制退出 bool quit = this-&gt;force.load() ? this-&gt;quit.load() : false; for(; !quit;)&#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;oper_lock); this-&gt;enable.wait(lock, [this]()&#123; return this-&gt;quit.load() || !this-&gt;tasks.empty(); &#125;); // 不是强制退出时可从这里退出 if(this-&gt;quit.load() &amp;&amp; this-&gt;tasks.empty())&#123; return; &#125; std::function&lt;void()&gt; task = std::move(this-&gt;tasks.front()); this-&gt;tasks.pop(); task(); &#125; &#125;)); &#125; &#125; void shutdown(bool force = false)&#123; this-&gt;quit.store(true); this-&gt;force.store(force); &#125; //void commit(std::function&lt;void (void * param)&gt; task); template&lt;class T, class... Args&gt; auto commit(T &amp;&amp; t, Args&amp;&amp;...args)-&gt;std::future&lt;decltype(t(args...))&gt;&#123; using TYPE = decltype(t(args...)); if(this-&gt;quit.load())&#123; //dont know return what, so throw an exception throw std::runtime_error(\"thread pool is alreay shutdown.\"); &#125; // 1、std::packaged_task&lt;decltype(f(args...))() 类似std::function\\ 但是会将其封装的可调用元素的结果封装在std::future中 // 2、std::make_shared 创建std::packaged_task&lt;decltype(f(args...))()\\ 类型的智能指针 // 3、std::bind(std::forward&lt;T&gt;(t), std::forward&lt;Args&gt;(args)...)当做\\ std::packaged_task的构造参数 auto task = std::make_shared&lt;std::packaged_task&lt;TYPE()&gt; &gt;( std::bind(std::forward&lt;T&gt;(t), std::forward&lt;Args&gt;(args)...) ); std::future&lt;TYPE&gt; result = task-&gt;get_future(); std::lock_guard&lt;std::mutex&gt; lock(this-&gt;oper_lock); //将packaged_task 包裹在一个签名为void()的lambda函数中调用,因为此lambda函数符合std::function&lt;void()&gt;\\ 的签名,所以可以放到queue中 this-&gt;tasks.emplace([task]()&#123; (*task)(); //调用packaged_task &#125;); this-&gt;enable.notify_one(); // 在线程池中唤醒一个休眠的线程 return result; &#125;private: //void move();private: std::vector&lt;std::thread&gt; pool; std::queue&lt;std::function&lt;void()&gt; &gt; tasks; int core; //线程池核心线程数 int max; //线程池根据tasks量以及cpu数最大可扩展的量 int cache; //运行tasks可缓存的最大task数,超出次数后commit将采取拒绝策略 std::atomic&lt;bool&gt; quit; //线程池shutdown条件, true时shutdown std::atomic&lt;bool&gt; force; //是否强制shutdown,true时有剩余的task将不执行直接退出, false时等待执行完所有的task再退出 std::condition_variable enable; // std::mutex oper_lock; // queue的读写锁&#125;;#endif ###Test Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;chrono&gt;#include \"./pool/ThreadPool.hpp\"int main(int argc, char** argv)&#123; ThreadPool pool(4); pool.start(); std::default_random_engine rd; std::uniform_int_distribution&lt;int&gt; rang(100, 1000); for(int idx = 0; idx &lt; 20; ++idx)&#123; pool.commit([=](int x, int y, int t)&#123; std::cout &lt;&lt; \"thread id : \" &lt;&lt; std::this_thread::get_id() &lt;&lt; \" x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; \" sleep time = \" &lt;&lt; t &lt;&lt; \" ms\" &lt;&lt; \" id = \" &lt;&lt; idx &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(t)); &#125;, rang(rd), rang(rd), rang(rd)); &#125; std::vector&lt;std::future&lt;int&gt; &gt; results; for (auto index = 20; index &lt; 50; ++index)&#123; results.push_back( pool.commit([=]()-&gt;int&#123; return index; &#125;) ); &#125; for ( auto &amp; r : results)&#123; std::cout &lt;&lt; \"get result from thread \" &lt;&lt; \" index = \" &lt;&lt; r.get() &lt;&lt; std::endl; &#125; char command = std::cin.get(); if (command == 'q')&#123; pool.shutdown(true); &#125;else if (command == 'e')&#123; pool.shutdown(true); try &#123; pool.commit([]()&#123; std::cout &lt;&lt; \"i want to get an exception\" &lt;&lt; std::endl; &#125;); &#125; catch(const std::exception&amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; '\\n'; &#125; &#125; std::cout &lt;&lt; \"test finish, OY!\" &lt;&lt; std::endl; return 0;&#125; Compile &amp; Link 1g++ -g -O3 -Wall -std=c++11 main.cpp -o ./out/test Run 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253thread id : 0x70000a352000 x = 242 y = 937 sleep time = 480 ms id = 0thread id : 0x70000a352000 x = 340 y = 390 sleep time = 692 ms id = 1thread id : 0x70000a352000 x = 188 y = 294 sleep time = 738 ms id = 2thread id : 0x70000a352000 x = 390 y = 978 sleep time = 270 ms id = 3thread id : 0x70000a4db000 x = 432 y = 780 sleep time = 102 ms id = 4thread id : 0x70000a458000 x = 652 y = 661 sleep time = 498 ms id = 5thread id : 0x70000a3d5000 x = 839 y = 452 sleep time = 487 ms id = 6thread id : 0x70000a352000 x = 698 y = 540 sleep time = 183 ms id = 7thread id : 0x70000a4db000 x = 157 y = 983 sleep time = 638 ms id = 8thread id : 0x70000a3d5000 x = 232 y = 823 sleep time = 766 ms id = 9thread id : 0x70000a458000 x = 801 y = 411 sleep time = 314 ms id = 10thread id : 0x70000a458000 x = 359 y = 912 sleep time = 294 ms id = 11thread id : 0x70000a458000 x = 260 y = 142 sleep time = 372 ms id = 12thread id : 0x70000a458000 x = 618 y = 499 sleep time = 831 ms id = 13thread id : 0x70000a458000 x = 108 y = 319 sleep time = 376 ms id = 14thread id : 0x70000a3d5000 x = 870 y = 490 sleep time = 519 ms id = 15thread id : 0x70000a352000 x = 446 y = 998 sleep time = 496 ms id = 16thread id : 0x70000a3d5000 x = 321 y = 308 sleep time = 610 ms id = 17thread id : 0x70000a3d5000 x = 247 y = 256 sleep time = 629 ms id = 18thread id : 0x70000a3d5000 x = 186 y = 484 sleep time = 703 ms id = 19get result from thread index = 20get result from thread index = 21get result from thread index = 22get result from thread index = 23get result from thread index = 24get result from thread index = 25get result from thread index = 26get result from thread index = 27get result from thread index = 28get result from thread index = 29get result from thread index = 30get result from thread index = 31get result from thread index = 32get result from thread index = 33get result from thread index = 34get result from thread index = 35get result from thread index = 36get result from thread index = 37get result from thread index = 38get result from thread index = 39get result from thread index = 40get result from thread index = 41get result from thread index = 42get result from thread index = 43get result from thread index = 44get result from thread index = 45get result from thread index = 46get result from thread index = 47get result from thread index = 48get result from thread index = 49ethread pool is alreay shutdown.test finish, OY!","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"http://www.zhangyebai.com/categories/FrameWork/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.zhangyebai.com/tags/C/"},{"name":"线程","slug":"线程","permalink":"http://www.zhangyebai.com/tags/线程/"},{"name":"线程池","slug":"线程池","permalink":"http://www.zhangyebai.com/tags/线程池/"}]},{"title":"LeetCode - 053 - Maximum-Sub-Array","slug":"maximum-sub-array","date":"2019-02-12T13:37:45.000Z","updated":"2019-02-12T14:45:46.080Z","comments":true,"path":"2019/02/12/maximum-sub-array/","link":"","permalink":"http://www.zhangyebai.com/2019/02/12/maximum-sub-array/","excerpt":"Description 官方地址 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法…… 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。","text":"Description 官方地址 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法…… 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。 Java Solution code ✔ Accepted ✔ 202/202 cases passed (16 ms) ✔ Your runtime beats 31.02 % of java submissions ✔ 2019-02-12 21:31:45 123456789101112131415class Solution &#123; public int maxSubArray(int[] nums) &#123; if (nums.length == 0)&#123; return 0; &#125; int sum = nums[0]; //sum保存着跟随idx遍历nums每个索引为结束位置的最大值（不是太好理解） int max = nums[0]; //max保存着idx及其以前的元素为结束位置的最大值 for ( int idx = 1; idx &lt; nums.length; ++idx)&#123; //注意idx从1开始,因为sum和max不能初始化为0, //只能初始化为nums[0],因为nums中的元素可能是负数 sum = Math.max(sum + nums[idx], nums[idx]); //注意sum是以idx索引元素为结束位置的最大值（包含idx） max = Math.max(sum, max); // &#125; return max; &#125;&#125; (max: 全局的最大值,也就是我们要求的结果; sum: 局部最大值,代表的是以某元素结尾的最大值) -1 2 -3 4 -1 idx = 0: sum = -1, max = -1 (注: 此步骤即是初始化sum和max, 也就是第一个元素为结尾的局部最大值和全局最大值) idx = 1: sum = (-1 + 2), max = sum = 1 idx = 2: sum = (1 + -3), max = 1 idx = 3: sum = 4, max = sum = 4 idx = 4: sum = (4 + -1), max = 4 所以求得结果max=4 注意到此题有dp解法,后续增加","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhangyebai.com/categories/LeetCode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhangyebai.com/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"}]},{"title":"LeetCode - 002 - Add Two Numbers (Medium)","slug":"add-two-numbers","date":"2017-02-19T07:08:44.000Z","updated":"2019-02-12T14:51:34.444Z","comments":true,"path":"2017/02/19/add-two-numbers/","link":"","permalink":"http://www.zhangyebai.com/2017/02/19/add-two-numbers/","excerpt":"Descripiton You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。 这句话什么意思呢？换句话说就是这样： 比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4); 19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1); 因为表示顺序是反着的，所以进位也是反着的。 假设这两个数字不包含任何的头结点0，除了数字0本身。 Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8","text":"Descripiton You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。 这句话什么意思呢？换句话说就是这样： 比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4); 19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1); 因为表示顺序是反着的，所以进位也是反着的。 假设这两个数字不包含任何的头结点0，除了数字0本身。 Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Solution 通过描述中的大致分析可以看出，需要遍历两个Linked-List中的对应的Node并取数相加，然后生成新Node并添加到result的Link-List中。 - 2个Linked-List中对应的Node，如果有一个为null，一个不为null，则结果节点直接使用不为null的Node中的值去构造即可; - 如果两个Node相加需要进位，切记是向后进位，如果有后续Node，计算是需要加上进位; - 如果两个Node相加需要进位，且没有后续Node，则需要添加一个Node，值用进位的数即可; - 以下代码截止到提交日期，均已被LeetCode AC； Python Solution code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env python# _*_ coding:utf-8 _*_#Node定义class ListNode(object): def __init__(self, x): self.val = x self.next = None#LeetCode的命名规范我已经无力吐槽了class Solution(object): def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" result = ListNode(0) step = result l_hand, r_hand = l1, l2 node_sum = 0 while l_hand is not None or r_hand is not None: node_sum //= 10 if l_hand is not None: node_sum += l_hand.val l_hand = l_hand.next if r_hand is not None: node_sum += r_hand.val r_hand = r_hand.next step.next = ListNode(node_sum % 10) step = step.next if node_sum // 10 &gt; 0: step.next = ListNode(1) return result.next#TestCasedef init_node(param)-&gt;ListNode: result_node, temp_node = None, None for value in param: if result_node is None: temp_node = ListNode(value) result_node = temp_node continue temp_node.next = ListNode(value) temp_node = temp_node.next return result_nodedef print_node(param_node: ListNode)-&gt;None: temp_node, values = param_node, [] while temp_node is not None: values.append(str(temp_node.val)) temp_node = temp_node.next print('[', '-&gt;'.join(values), ']', sep=None)if __name__ == '__main__': l_node = init_node([3, 7]) r_node = init_node([9, 2]) print_node(Solution().add_two_nums(l_node, r_node)) Java Solution code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode result = new ListNode(0); ListNode step = result; ListNode l_hand = l1; ListNode r_hand = l2; int node_sum = 0; for(;l_hand != null || r_hand != null;)&#123; node_sum /= 10; if (l_hand != null)&#123; node_sum += l_hand.val; l_hand = l_hand.next; &#125; if (r_hand !=null)&#123; node_sum += r_hand.val; r_hand = r_hand.next; &#125; step.next = new ListNode(node_sum % 10); step = step.next; &#125; if (node_sum / 10 &gt; 0)&#123; step.next = new ListNode(1); &#125; return result.next; &#125; //TestCase public static void printNode(ListNode node)&#123; while (node != null)&#123; System.out.println(node.val); node = node.next; &#125; &#125; public static void main(String[] args)&#123; //不要问我这两个数组时哪里来的，没有错误的程序是不会知道的 int[] arr1 = &#123;1,6,6,0,5,8,1,0,7&#125;; int[] arr2 = &#123;8,2,5,7,9,1,0,2,2,1&#125;; printNode(new AddTwoNumbers().addTwoNumbers(initList(arr1), initList(arr2))); &#125;&#125;class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; C++ Solution code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#ifndef NULL#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif#endifstruct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125; &#125;;class AddTwoNumbers &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode head(0); ListNode *step = &amp;head, *l_hand = l1, *r_hand = l2; int node_sum = 0; for (; l_hand || r_hand;) &#123; node_sum /= 10; if (l_hand) &#123; node_sum += l_hand-&gt;val; l_hand = l_hand-&gt;next; &#125; if (r_hand) &#123; node_sum += r_hand-&gt;val; r_hand = r_hand-&gt;next; &#125; step-&gt;next = new ListNode(node_sum % 10); step = step-&gt;next; &#125; if (node_sum / 10 &gt; 0) &#123; step-&gt;next = new ListNode(1); &#125; return head.next; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhangyebai.com/categories/LeetCode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhangyebai.com/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"},{"name":"Python","slug":"Python","permalink":"http://www.zhangyebai.com/tags/Python/"},{"name":"C++","slug":"C","permalink":"http://www.zhangyebai.com/tags/C/"}]},{"title":"Singleton - 单例模式 - Java","slug":"Singleton","date":"2017-02-13T15:48:30.000Z","updated":"2019-02-12T14:42:52.315Z","comments":true,"path":"2017/02/13/Singleton/","link":"","permalink":"http://www.zhangyebai.com/2017/02/13/Singleton/","excerpt":"单例模式 One instance of a class or one value accessible globally in an application. Ensure that only one instance of a class is created. Provide a global point of access to the object. 在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点: 确保该唯一实例被创建。 为外界使用该实例提供一个全局的访问入口。 对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。","text":"单例模式 One instance of a class or one value accessible globally in an application. Ensure that only one instance of a class is created. Provide a global point of access to the object. 在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点: 确保该唯一实例被创建。 为外界使用该实例提供一个全局的访问入口。 对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。 简单懒汉式单例模式 - 简单 * 3，但是致命缺点是线程不安全。 - 懒汉式:在Singleton被ClassLoader加载时并不实例化instance，只有在需要时(即调用getInstance方法时)才会触发实例化。 - getInstance，newInstance在命名规范上的区别是分别对应单例和多例! code 123456789101112131415161718192021222324252627282930313233343536373839404142public class Singleton implements java.io.Serializable &#123; private static Singleton instance; private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次 3mspublic static void testRuntime()&#123; long timestart = System.currentTimeMillis(); for (int index = 0, loop = 10000000; index &lt; loop; ++index)&#123; Singleton singletonThread1 = Singleton.getSingletonInstance(); &#125; &#125; long timeend = System.currentTimeMillis(); System.out.println(timeend - timestart);&#125;//MultipleInstanceTestCaseclass MultipleTest implements Runnable&#123; public Map&lt;Singleton, Integer&gt; hMap = new Hashtable&lt;&gt;(); @Override public void run() &#123; Singleton singleton = Singleton.getSingletonInstance(); hMap.put(singleton, 0); &#125; &#125;/*开启了100000个线程测试，并未发现有多个实例的现象，但是此种做法确实是存在多例的风险，原因在于当两个线程同时调用 getSingletonInstance()且instance都为null时，两个线程可能会同时执行instance = new Singleton();*/ 线程安全懒汉式单例模式 - 通过对全局入口方法加同步来解决线程安全的问题。 - 带来的后果是资源的开销是非常大的，因为初始化完instance后不再需要synchronized - 毕竟线程安全了。 code 1234567891011121314151617181920212223public class Singleton implements java.io.Serializable &#123; private static Singleton instance; private Singleton()&#123; &#125; public static synchroized Singleton getSingletonInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次调用 56ms （简单懒汉式单例模式中为3ms）//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 改进效率版懒汉式单例模式 - synchroized 同步方法的资源开销是很大的。 - 改进点在于用synchronized同步实例化代码块，这样的好处是一旦实例化完成，以后的调用不会再触碰到synchronized。 code 123456789101112131415161718192021222324252627public class Singleton implements java.io.Serializable&#123; private volatile static Singleton instance; private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; if (instance == null)&#123; synchroized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次调用 3ms 理论上来说应该于 简单懒汉式单例模式 中的实现效率持平。//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 饿汉式单例模式 - 触发ClassLoader加载该类时实例化。 - 与懒汉式的区别是:主动实例化。 code 12345678910111213141516171819202122232425262728293031323334353637public class Singleton implements java.io.Serializable&#123; private static Singleton instance = new Singleton(); private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//另一种写法是通过静态代码块实例化public class Singleton implements java.io.Serializable&#123; private static Singleton instance; static&#123; instance = new Singleton(); &#125; private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次调用 2ms。//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 静态内部类实现单例 - 实现延迟实例化。 - 线程安全。 - 推荐使用。 code 12345678910111213141516171819public class Singleton implements java.io.Serializable&#123; private static class SingletonController&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getSingletonInstance()&#123; return SingletonController.instance; &#125; private Object readResolve()&#123; return SingletonController.instance;; &#125;&#125;//RuntimeTestCase 10000000次调用 3ms 。//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 枚举实现 最近在看《Effective java 中文版2th》的时候，看到的此种方法，顿时被惊呆。以下为书中原话: - since jdk 1.5 。 - 只需编写一个包含单个元素的枚举类型即可实现。 - 此方法在功能上与公有域方法接近，但是它更加简洁，无偿地提供了序列化机制。 - 绝对的防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。 - 虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。 code 1234public enum Singleton&#123; INSTANCE; //代码至此已经完事。&#125;","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://www.zhangyebai.com/categories/Design-Pattern/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.zhangyebai.com/tags/设计模式/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://www.zhangyebai.com/tags/Design-Pattern/"}]},{"title":"LeetCode - 001 - Two Sum (Easy)","slug":"two-sum","date":"2017-02-12T21:02:51.000Z","updated":"2019-02-12T14:51:39.055Z","comments":true,"path":"2017/02/13/two-sum/","link":"","permalink":"http://www.zhangyebai.com/2017/02/13/two-sum/","excerpt":"Descripiton Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。 假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。 Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].","text":"Descripiton Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。 假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。 Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Solution 利用map数据结构的Key-Value键值对的存储特点，遍历array数组时，查看当前数组元素value与目标target的差（target - value）是否在map的keys中，如果存在说明前面的遍历时找到了第一个value，取出索引并返回当前索引即可;如果没找到，将当前value作为key，当前索引index作为key的value放置进map继续遍历即可。 Python中map数据结构为字典（dict） 适当关注一下c++中std::map和std::vector的相关操作 以下代码截止到提交日期，均已被LeetCode AC Python Solution code 123456789101112131415161718192021#!/usr/bin/env python# _*_ coding:utf-8 _*_class Solution(object): def two_num(nums, target)-&gt;object: nums_dict = &#123;&#125; for loop, value in enumerate(nums): if nums_dict.__contains__(target - value): return [nums_dict[target - value], loop] else: nums_dict[value] = loop#TestCaseif __name__ == '__main__': num_list = [2, 7, 11, 15] target_num = 22 result = Solution().two_num(num_list, target_num) try: for index in result: print('-&gt;'.join([str(index), str(num_list[index])])) except TypeError: print('no target to find') Java Solution code 123456789101112131415public class Solution&#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&amp;ltInteger, Integer&gt; map = new HashMap&amp;ltInteger, Integer&gt;(); for(int index = 0, length = nums.length; index &lt; length; ++index)&#123; if (map.containsKey(target - nums[index]))&#123; result[0] = map.get(target - nums[index]); result[1] = index; &#125;else&#123; map.put(nums[index], index); &#125; &#125; return result; &#125;&#125; C++ Solution code 123456789101112131415161718192021222324252627282930313233343536#include &lt;vector&gt;#include &lt;map&gt;class Solution &#123;public: std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt;&amp; nums, int target) &#123; std::vector&lt;int&gt; result; std::map&lt;int, int&gt; loop; for (std::size_t index = 0; index &lt; nums.size(); ++index) &#123; if (loop.find(target - nums.at(index)) != loop.cend()) &#123; result.push_back(loop.at(target - nums.at(index))); result.push_back(index); &#125; else &#123; loop.insert(std::map&lt;int, int&gt;::value_type(nums.at(index), index)); &#125; &#125; return result; &#125;&#125;;//TestCase#include &lt;iostream&gt;int main()&#123; Solution solution; std::vector&lt;int&gt; nums = &#123; 2, 7, 11, 15 &#125;; std::vector&lt;int&gt; result = solution.twoSum(nums, 9); for(std::vector&lt;int&gt;::iterator iter = result.begin(); iter != result.end(); ++iter) std::cout &lt;&lt; *iter &lt;&lt; std::endl; int timing = 0; std::cin &gt;&gt; timing; return 0;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhangyebai.com/categories/LeetCode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhangyebai.com/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"},{"name":"Python","slug":"Python","permalink":"http://www.zhangyebai.com/tags/Python/"},{"name":"C++","slug":"C","permalink":"http://www.zhangyebai.com/tags/C/"}]}]}