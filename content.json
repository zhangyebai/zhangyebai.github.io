{"meta":{"title":"一码平川","subtitle":null,"description":null,"author":"张夜白","url":"http://www.zhangyebai.com"},"pages":[{"title":"categories","date":"2019-02-12T09:26:15.000Z","updated":"2019-02-12T09:30:58.238Z","comments":true,"path":"categories/index.html","permalink":"http://www.zhangyebai.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-02-12T09:26:01.000Z","updated":"2019-02-12T09:30:44.034Z","comments":true,"path":"tags/index.html","permalink":"http://www.zhangyebai.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-02-12T09:52:52.000Z","updated":"2019-02-12T09:58:13.812Z","comments":true,"path":"about/index.html","permalink":"http://www.zhangyebai.com/about/index.html","excerpt":"","text":"张夜白 GitHub 北京 29"}],"posts":[{"title":"redis里的小秘密[0x00]","slug":"secret-in-redis-0x00","date":"2019-02-17T09:51:43.000Z","updated":"2019-02-17T17:57:06.441Z","comments":true,"path":"2019/02/17/secret-in-redis-0x00/","link":"","permalink":"http://www.zhangyebai.com/2019/02/17/secret-in-redis-0x00/","excerpt":"linux macOS下设置进程名 base on redis source code 5.0.3 在redis server启动过程中, 有一个宏和一个函数显得很奇特, 他们是server.c中main()函数 中的第一个宏和第一个函数, 宏INIT_SETPROCTITLE_REPLACEMENT和函数spt_init(argc, argv);. 他俩组合在一起的主要功能是在macOS和*nix下设置(修改)redis的各个进程名, 例如redis-aof-rewrite、 redis-rdb-bgsave等。 那么他们是如何工作的呢?想知道这些, 这得从main函数说起。请看标准的main函数签名: 1int main(int argc, char ** argv);","text":"linux macOS下设置进程名 base on redis source code 5.0.3 在redis server启动过程中, 有一个宏和一个函数显得很奇特, 他们是server.c中main()函数 中的第一个宏和第一个函数, 宏INIT_SETPROCTITLE_REPLACEMENT和函数spt_init(argc, argv);. 他俩组合在一起的主要功能是在macOS和*nix下设置(修改)redis的各个进程名, 例如redis-aof-rewrite、 redis-rdb-bgsave等。 那么他们是如何工作的呢?想知道这些, 这得从main函数说起。请看标准的main函数签名: 1int main(int argc, char ** argv); macOS和*nix系统创建进程后会给进程分配一个全局的environment环境变量char ** environ, 它是一个char*数组, 里面保存的是类似{k=v, k=v, k=v}这样的字符串数组。如果我们想使用它可以像下面这样(实际上redis也是这样做的): 12345678910#include &lt;iostream&gt;extern char ** environ;int main(int argc, char ** argv)&#123; for (auto idx = 0; idx &lt; argc; ++idx)&#123; std::cout &lt;&lt; static_cast&lt;void*&gt;(argv[idx]) &lt;&lt; \" = \" &lt;&lt; argv[idx] &lt;&lt; std::endl; &#125; for(auto idx = 0; nullptr != environ[idx]; ++idx)&#123; std::cout &lt;&lt; static_cast&lt;void*&gt;(environ[idx]) &lt;&lt; \" = \" &lt;&lt; environ[idx] &lt;&lt; std::endl; &#125;&#125; 12g++ -Wall -std=c++11 main.cpp -o test./test 在我的mac下运行结果如下(其实就是系统给进程设置的环境变量): 12345678910111213141516171819202122232425262728290x7ffeed1afa80 = ./test // argv[0]0x7ffeed1afa87 = __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0 //environ[0]0x7ffeed1afaad = TMPDIR=/var/folders/5y/c9fbgn3x6p90sl9gbx_y1qnm0000gn/T/0x7ffeed1afae6 = HOME=/Users/zhangyebai0x7ffeed1afafd = SHELL=/bin/zsh0x7ffeed1afb0c = Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.Ey7nIaeRPX/Render0x7ffeed1afb58 = SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.CT1oMhwGyS/Listeners0x7ffeed1afb9a = PATH=/usr/local/opt/icu4c/sbin:/usr/local/opt/icu4c/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/opt/icu4c/sbin:/usr/local/opt/icu4c/bin:/usr/local/sbin:/Users/zhangyebai/scripts:/usr/local/mysql/bin:/Users/zhangyebai/scripts:/usr/local/mysql/bin0x7ffeed1afcb0 = LOGNAME=zhangyebai0x7ffeed1afcc3 = XPC_SERVICE_NAME=00x7ffeed1afcd6 = COMMAND_MODE=unix20030x7ffeed1afcec = USER=zhangyebai0x7fe8f2502450 = XPC_FLAGS=0x00x7ffeed1afd0a = TERM_PROGRAM=vscode0x7ffeed1afd1e = TERM=xterm-256color0x7ffeed1afd32 = TERM_PROGRAM_VERSION=1.31.10x7ffeed1afd4e = TERM_SESSION_ID=3B84E1B2-C0C2-426C-8AE3-00C01A9F6D5B0x7ffeed1afd83 = ZSH=/Users/zhangyebai/.oh-my-zsh0x7ffeed1afda4 = PAGER=less0x7ffeed1afdaf = LSCOLORS=Gxfxcxdxbxegedabagacad0x7ffeed1afdcf = PWD=/Users/zhangyebai/code/cpp/redis0x7ffeed1afdf4 = SHLVL=10x7ffeed1afdfc = LESS=-R0x7ffeed1afe04 = LC_CTYPE=en_US.UTF-80x7ffeed1afe19 = SECURITYSESSIONID=186a90x7ffeed1afe31 = APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL=true0x7ffeed1afe61 = OLDPWD=/Users/zhangyebai/code/cpp/redis/testdwnakdihjwaijdiwaljdiowadwadwadwa.dSYM0x7ffeed1afeb4 = LANG=en_US.UTF-80x7ffeed1afec5 = _=/Users/zhangyebai/code/cpp/redis/./test environ 跟int main(int argc, char ** argv)有着什么样的关系呢? 如下所示: \b'argv[0][content]\\0' 'argv[1][content]\\0' ... 'argv[n][content]\\0' nullptr 'environ[0][content]\\0' 'environ[1][content]\\0' ... 'envrion[x][content]\\0' 可以看到他们是一段连续的内存, 下面我们举个例子把它实例化看一下: argv[0] argv[1] nullptr environ[0] environ[1] a \\0 b \\0 nullptr d=2\\0 e=3\\0 0 1 2 3 4567 891011 base = 0x7ffeeaf21a80 offset = 0, 1, 2 ... 11 说完argv、environ的内存布局, 我们就可以开始看redis是如何设置进程名的了, 这里先直接给出答案: argv[0]里面对应的就是进程名。但是先别着急, 想要修改它可也没那么容易。因为什么? 上面我们说了, argv、environ可是内存连续的, 如果你设置了一个新的进程名长度比原来的长, 那么悲剧即将发生。它将覆盖argv[0]后面的缓冲区, 这将是致命的。argv、environ在进程运行过程中随时可能会用到,它们很重要。好了, 下面我们看redis怎么做的: 123456789// server.c line 4035 version 5.0.3int main(int argc, char ** argv)&#123; //....more /* We need to initialize our libraries, and the server configuration. */#ifdef INIT_SETPROCTITLE_REPLACEMENT spt_init(argc, argv);#endif //...more&#125; 在setproctitle.c中line 152展开spt_init(argc, argv);, 我们一行一行来看(这里点名表扬redis的函数尾注释): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116void spt_init(int argc, char *argv[]) &#123; char **envp = environ; char *base, *end, *nul, *tmp; int i, error; /* 注意这里的base, 被赋值argv[0],由于上面说了argv和environ 是内存连续的, 在经历下面的操作以后argv 和 environ这边连续 的内存将退化成char*类型的base */ if (!(base = argv[0])) return; // nul表示argv[0], 也就是base字符串, // 也就是进程名字符串的结束位置(不包括\\0) nul = &amp;base[strlen(base)]; end = nul + 1; /* 虽然argv和environ是连续的内存, 但是其中包含\\0, 而且不知道 environ的长度,所以得遍历二者, 将这片内存退化成char*, 也就是base step 1: 遍历argv note: for循环的条件判断很奇怪, 我暂时没遇到满足这样奇怪条件 的启动参数, 可能redis的开发人员在不同的操作系统上遇到这么怪异 的问题, 有待探究。 */ for (i = 0; i &lt; argc || (i &gt;= argc &amp;&amp; argv[i]); i++) &#123; if (!argv[i] || argv[i] &lt; end) continue; end = argv[i] + strlen(argv[i]) + 1; &#125; /* step 2: 遍历 environ note: for循环中的这个if判断同样很奇怪 */ for (i = 0; envp[i]; i++) &#123; if (envp[i] &lt; end) continue; end = envp[i] + strlen(envp[i]) + 1; &#125; /** SPT是一个全局变量结构体: static struct &#123; // original value const char *arg0; // title space available char *base, *end; // pointer to original nul character within base char *nul; _Bool reset; int error; &#125; SPT; */ // 这一步很关键, 将原进程名备份 if (!(SPT.arg0 = strdup(argv[0]))) goto syerr;#if __GLIBC__ /** 释放跟argv有关的内存 */ if (!(tmp = strdup(program_invocation_name))) goto syerr; program_invocation_name = tmp; if (!(tmp = strdup(program_invocation_short_name))) goto syerr; program_invocation_short_name = tmp;#elif __APPLE__ /** 释放跟argv有关的内存 */ if (!(tmp = strdup(getprogname()))) goto syerr; setprogname(tmp);#endif /** 重新设置了env, 具体怎么实现我们等会跳进去看。 只需要知道, 这个函数执行过以后, 将在新的内存区域 产生新的environ, 原来的environ内存区域将归base所有 */ if ((error = spt_copyenv(envp))) goto error; /** 重新设置了除argv[0]以外的所有argv, 具体怎么实现我们等会跳进去看。 只需要知道, 这个函数执行过以后, 将在新的内存区域 产生新的除argv[0]以外的argv, 原来的argv[1-n]内存区域将归base所有 */ if ((error = spt_copyargs(argc, argv))) goto error; /** 至此, 原来argv environ共有的那片连续内存全部被转换成base, 即 char*, 也是argv[0], 也就是进程名。argv和environ将不再连续, 新的 内荣全部由strdup生成 我们修改进程名, 只需要改SPT-&gt;base就可以了。 */ SPT.nul = nul; SPT.base = base; SPT.end = end; return;syerr: error = errno;error: SPT.error = error;&#125; /* spt_init() */ 现在我们在setproctitle.c的line 103展开spt_copyenv(envp): 1234567891011121314151617181920212223242526272829303132333435363738394041424344static int spt_copyenv(char *oldenv[]) &#123; extern char **environ; char *eq; int i, error; /** 如果environ != oldenv则说明environ已经被设置过了 直接返回成功 */ if (environ != oldenv) return 0; /** 让老的environ失效,但是不释放那片内存 这个函数有一段血泪史, 等下我们展开 */ if ((error = spt_clearenv())) goto error; /** setenv会生成新的environ, 不必手动设置新environ的内存 注意setenv中取值的写法, 这是c语言优秀的精华 */ for (i = 0; oldenv[i]; i++) &#123; if (!(eq = strchr(oldenv[i], '='))) continue; *eq = '\\0'; error = (0 != setenv(oldenv[i], eq + 1, 1))? errno : 0; *eq = '='; if (error) goto error; &#125; return 0; /** 如果设置过程中出问题了, 则还原environ的设置 */error: environ = oldenv; return error;&#125; /* spt_copyenv() */ 现在我们来述说那段血泪史, 我们在setproctitle.c的line 83展开spt_clearenv();: 这里面是redis作者对cleanrenv()最深沉的吐槽 1234567891011121314151617181920212223242526272829303132333435/* * For discussion on the portability of the various methods, see * http://lists.freebsd.org/pipermail/freebsd-stable/2008-June/043136.html *//** 看上面这段注释中的链接, redis作者写了好几种实现方法来兼容macOS和*nix系统, 至今未果 现在的这段实现里面macOS是问号,但是我亲测it works step 1: 扔给系统一个空environ, 让原来的environ失效 step 2: 再设置新的environ*/static int spt_clearenv(void) &#123;#if __GLIBC__ clearenv(); return 0;#else extern char **environ; static char **tmp; /** 及其怪异的写法,其实相当于: char * arr[1] = &#123;nullptr&#125;; temp = static_cast&lt;char**&gt;(arr); environ = temp; 它的这个写法, 我思考了好久。这里也不得不吐槽, c语言灵活的没边了... void *一时爽, 回看火葬场。 */ if (!(tmp = malloc(sizeof *tmp))) return errno; tmp[0] = NULL; environ = tmp; return 0;#endif&#125; /* spt_clearenv() */ 现在我们在setproctitle.c的line 103展开spt_copyargs(argc, argv);: 12345678910111213141516171819202122static int spt_copyargs(int argc, char *argv[]) &#123; char *tmp; int i; /** 除argv[0]以外的所有argv都由strdup重新生成 注意由strdup生成的char*是需要free的 redis里由于就在这里用到, 并且这些参数是给系统使用, 而且所有函数都只调用一次所以就没有free */ for (i = 1; i &lt; argc || (i &gt;= argc &amp;&amp; argv[i]); i++) &#123; if (!argv[i]) continue; if (!(tmp = strdup(argv[i]))) return errno; argv[i] = tmp; &#125; return 0;&#125; /* spt_copyargs() */ 现在我们在setproctitle.c的line 103展开setproctitle(const char fmt, ...): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//SPT_MAXTITLE = 255;void setproctitle(const char *fmt, ...) &#123; char buf[SPT_MAXTITLE + 1]; /* use buffer in case argv[0] is passed */ va_list ap; char *nul; int len, error; if (!SPT.base) return; if (fmt) &#123; va_start(ap, fmt); len = vsnprintf(buf, sizeof buf, fmt, ap); va_end(ap); &#125; else &#123; len = snprintf(buf, sizeof buf, \"%s\", SPT.arg0); &#125; if (len &lt;= 0) &#123; error = errno; goto error; &#125; if (!SPT.reset) &#123; memset(SPT.base, 0, SPT.end - SPT.base); SPT.reset = 1; &#125; else &#123; memset(SPT.base, 0, spt_min(sizeof buf, SPT.end - SPT.base)); &#125; /** 一顿操作base nul end。终于通过memcpy将我们的新进程名设置进去了 其实我觉得nul用的没有意义... 也可能是有序的代码里面会用到?(如果有的话以后更新) */ len = spt_min(len, spt_min(sizeof buf, SPT.end - SPT.base) - 1); memcpy(SPT.base, buf, len); nul = &amp;SPT.base[len]; if (nul &lt; SPT.nul) &#123; *SPT.nul = '.'; &#125; else if (nul == SPT.nul &amp;&amp; &amp;nul[1] &lt; SPT.end) &#123; *SPT.nul = ' '; *++nul = '\\0'; &#125; return;error: SPT.error = error;&#125; /* setproctitle() */ 最后, 从redis中偷师, 用c++11写了一个header only的设置进程名的小库: setproctitle 同时该工程下还有以下两个小玩意儿: c11线程池 c++11 std::functional lambda c11时间库 跨平台, 几乎能支持所有你的习惯来操作时间~ 部分setproctitle: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#ifndef _UTIL_H_#define _UTIL_H_#include &lt;string&gt; //strlen(2) strdup(1)#include &lt;math.h&gt; //min(1)/** * origin: 进程原始名 * base: char数组, 存储修改后的进程名 * nul: * end: * */typedef struct _PROC_TITLE_INFO&#123; const char * origin; char * base, *nul, *end;&#125;PTI, *PPTI;extern char ** environ;class Util&#123;private: Util() = default; ~Util() = default;public: /** * gloabl init function, keep it be called only once * */ static PPTI init_proc_title_info(int argc, char ** argv)&#123; auto ** envp = environ; auto base = argv[0]; if(nullptr == base)&#123; return nullptr; &#125; char * end = (&amp;base[strlen(base)]) + 1; // +1 for '\\0' for (auto idx = 0; idx &lt; argc || (idx &gt;= argc &amp;&amp; nullptr != argv[idx]); ++idx)&#123; // 不知道redis为什么这样写, 我猜可能是遇到特殊的argv, 待探索 if(nullptr == argv[idx] || argv[idx] &lt; end)&#123; //注意这里比较的都是指针,不涉及到数据 continue; &#125; end = argv[idx] + strlen(argv[idx]) + 1; // +1 for '\\0' &#125; for (auto idx = 0; nullptr != envp[idx]; ++idx)&#123; if (envp[idx] &lt; end)&#123; //注意这里比较的都是指针,不涉及到数据 continue; &#125; end = envp[idx] + strlen(envp[idx]) + 1; // +1 for '\\0' &#125; PPTI ppti = new PTI(); ppti-&gt;origin = strdup(argv[0]); if(nullptr == ppti-&gt;origin)&#123; delete ppti; ppti = nullptr; return ppti; &#125; #ifdef __GLIBC__ //TODO #elif __APPLE__ auto name = strdup(getprogname()); if(nullptr == name)&#123; free(const_cast&lt;char *&gt;(ppti-&gt;origin)); delete ppti; ppti = nullptr; return ppti; &#125; setprogname(name); #endif if( !set_new_env(environ) )&#123; free(const_cast&lt;char *&gt;(ppti-&gt;origin)); delete ppti; ppti = nullptr; return ppti; &#125; if( !set_new_argv(argc, argv) )&#123; free(const_cast&lt;char *&gt;(ppti-&gt;origin)); delete ppti; ppti = nullptr; return ppti; &#125; ppti-&gt;base = base; ppti-&gt;end = end; return ppti; &#125; static bool set_proc_title(const PPTI ppti, const char * fmt, ...)&#123; if(nullptr == ppti)&#123; return false; &#125; if(nullptr == ppti-&gt;base)&#123; return false; &#125; char buf[256] = &#123;0&#125;; va_list ap; auto len = 0; if(nullptr != fmt)&#123; va_start(ap, fmt); len = vsnprintf(buf, sizeof buf, fmt, ap); va_end(ap); &#125;else&#123; len = snprintf(buf, sizeof buf, \"%s\", ppti-&gt;origin); &#125; if(len &lt;= 0)&#123; return false; &#125; memset(ppti-&gt;base, 0, len + 1); memcpy(ppti-&gt;base, buf, len); return true; &#125; private: template&lt;class T&gt; static T min(T &amp;&amp; l, T &amp;&amp; r)&#123; return l &gt; r ? r : l; &#125; static bool set_new_argv(int argc, char ** argv)&#123; for(auto idx = 1; idx &lt; argc || (idx &gt;= argc &amp;&amp; nullptr != argv[idx]); ++idx)&#123; if(nullptr == argv[idx])&#123; continue; &#125; auto arg = strdup(argv[idx]); if(nullptr == arg)&#123; return false; &#125; argv[idx] = arg; &#125; return true; &#125; static bool set_new_env(char ** old_env)&#123; extern char ** environ; if( environ != old_env)&#123; return true; &#125; if(! clear_env())&#123; environ = old_env; return false; &#125; char * eq = nullptr; for (auto idx = 0; nullptr != old_env[idx]; ++idx)&#123; eq = strchr(old_env[idx], '='); if(nullptr == eq)&#123; continue; &#125; *eq = '\\0'; int result = setenv(old_env[idx], eq + 1, true); *eq = '='; if(0 != result)&#123; environ = old_env; return false; &#125; &#125; return true; &#125; static bool clear_env(void)&#123; #ifdef __GLIBC__ //TODO #else extern char ** environ; /** * 相当于 char * arr[1] = &#123;nullptr&#125;; * static char ** temp_env = statc_cast&lt;char **&gt;(arr); * 其主要目的是为了使environ变成空置,从而使environ失效 * 关于这个函数的实现请点击下面的链接查看redis作者对其的说明和吐槽 * For discussion on the portability of the various methods, see * http://lists.freebsd.org/pipermail/freebsd-stable/2008-June/043136.html */ static char ** temp_env = static_cast&lt;char **&gt;(malloc(sizeof *temp_env)); if(nullptr == temp_env)&#123; return false; &#125; temp_env[0] = nullptr; environ = temp_env; return true; #endif &#125;&#125;;#endif 测试代码: 12345678910111213141516#include &lt;iostream&gt;#include \"./common/Util.hpp\"extern char **environ;//#define UNUSED(x) (void)x;int main(int argc, char ** argv)&#123; auto ppti = Util::init_proc_title_info( argc, argv); std::cout &lt;&lt; ppti-&gt;origin &lt;&lt; \"-\" &lt;&lt; ppti-&gt;base &lt;&lt; std::endl;; std::cout &lt;&lt; Util::set_proc_title(ppti, \"%s-%d\", \"named\", 1) &lt;&lt; std::endl; std::cout &lt;&lt; getprogname() &lt;&lt; std::endl; std::cout &lt;&lt; getprogname() &lt;&lt; std::endl; std::cout &lt;&lt; ppti-&gt;end - ppti-&gt;base &lt;&lt; std::endl; std::cin.get();&#125; 12g++ -Wall -std=c++11 -O3 main.cpp -o test./test 结果: 1234ps -ef | grep named501 99907 50309 0 1:49AM ttys002 0:00.00 named-1qquit","categories":[{"name":"源码趣闻","slug":"源码趣闻","permalink":"http://www.zhangyebai.com/categories/源码趣闻/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.zhangyebai.com/tags/redis/"},{"name":"c","slug":"c","permalink":"http://www.zhangyebai.com/tags/c/"},{"name":"c++","slug":"c","permalink":"http://www.zhangyebai.com/tags/c/"}]},{"title":"格式化输出字典 —— 编程之禅 —— 一行代码系列","slug":"python-zen-format-dict-one-word","date":"2019-02-14T15:23:20.000Z","updated":"2019-02-14T15:57:43.161Z","comments":true,"path":"2019/02/14/python-zen-format-dict-one-word/","link":"","permalink":"http://www.zhangyebai.com/2019/02/14/python-zen-format-dict-one-word/","excerpt":"The Zen of Python: One Line Code 今天有一位Python刚入门的女性朋友请教我一个问题: 有一个list, 其中存储的是dict, 每个dict 的key是相同的,dict的值是整型数值, 请用Python代码将其输出成表格格式。例如: [{'a': 1, 'b': 2, 'c': 3}, {'a': 4, 'b': 5, 'c': 6}, {'a': 7, 'b': 8, 'c': 9}] =&gt; a b c 1 2 3 4 5 6 7 8 9 其实是很简单的需求, 后来仔细琢磨想起逛知乎时大家晒的一行代码,决定尝试一下。刚开始思考从各种iterator入手 做处理, 尝试了很久不得其法。由于这两年写Java写的太多,灵光一闪想到functional program中各种apply、map、 reduce、filter等函数式写法, 一查之下Python果然有这种写法,遂得之。代码如下 One Line Code 1234567891011#! /usr/bin/env python# -*- coding: utf-8 -*-def format(lst: list) -&gt; str: return '\\n'.join([' '.join(lst[0]), '\\n'.join(map(lambda d : ' '.join([str(x) for x in d.values()]), lst))])if __name__ == '__main__': data = [&#123;'a': 1, 'b': 2, 'c': 3&#125;, &#123;'a': 4, 'b': 5, 'c': 6&#125;, &#123;'a': 7, 'b': 8, 'c': 9&#125;] print(format(data))","text":"The Zen of Python: One Line Code 今天有一位Python刚入门的女性朋友请教我一个问题: 有一个list, 其中存储的是dict, 每个dict 的key是相同的,dict的值是整型数值, 请用Python代码将其输出成表格格式。例如: [{'a': 1, 'b': 2, 'c': 3}, {'a': 4, 'b': 5, 'c': 6}, {'a': 7, 'b': 8, 'c': 9}] =&gt; a b c 1 2 3 4 5 6 7 8 9 其实是很简单的需求, 后来仔细琢磨想起逛知乎时大家晒的一行代码,决定尝试一下。刚开始思考从各种iterator入手 做处理, 尝试了很久不得其法。由于这两年写Java写的太多,灵光一闪想到functional program中各种apply、map、 reduce、filter等函数式写法, 一查之下Python果然有这种写法,遂得之。代码如下 One Line Code 1234567891011#! /usr/bin/env python# -*- coding: utf-8 -*-def format(lst: list) -&gt; str: return '\\n'.join([' '.join(lst[0]), '\\n'.join(map(lambda d : ' '.join([str(x) for x in d.values()]), lst))])if __name__ == '__main__': data = [&#123;'a': 1, 'b': 2, 'c': 3&#125;, &#123;'a': 4, 'b': 5, 'c': 6&#125;, &#123;'a': 7, 'b': 8, 'c': 9&#125;] print(format(data)) Origin Code 1234567891011121314#! /usr/bin/env python# -*- coding: utf-8 -*-def format(lst: list) -&gt; str: header = ' '.join(lst[0]) store = [] for item in lst: store.append(' '.join(str(x) for x in item.values())) return '\\n'.join([header, '\\n'.join(store)])if __name__ == '__main__': data = [&#123;'a': 1, 'b': 2, 'c': 3&#125;, &#123;'a': 4, 'b': 5, 'c': 6&#125;, &#123;'a': 7, 'b': 8, 'c': 9&#125;] print(format(data))","categories":[{"name":"编程之禅","slug":"编程之禅","permalink":"http://www.zhangyebai.com/categories/编程之禅/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.zhangyebai.com/tags/Python/"},{"name":"zen","slug":"zen","permalink":"http://www.zhangyebai.com/tags/zen/"}]},{"title":"手写线程池 modern-cpluscplus-threadpool","slug":"modern-cpluscplus-threadpool","date":"2019-02-14T06:38:00.000Z","updated":"2019-02-14T15:42:24.679Z","comments":true,"path":"2019/02/14/modern-cpluscplus-threadpool/","link":"","permalink":"http://www.zhangyebai.com/2019/02/14/modern-cpluscplus-threadpool/","excerpt":"C++线程池 进程的创建和销毁,代价是昂贵的,除去操作系统的实现及其本身的原理,跟线程相比它更显得重量级。 这几年互联网的迅速发展,让线程正面临着跟进程一样的“重量级”困扰。尤其是GO等语言推出协程(纤程) 后,线程更是不堪其重。那么有没有改进的方向呢？有,将线程池化——线程池。 由于C++版本推进的历程(C++98, C++03, C++11, C++14, C++17, C++20)以及其 弱鸡般的ABI兼容性,导致很多框架用起来得自己造轮子。C++版本再吐槽一句好了, C++即使版本推进到 0xff, 对很多人来说还是c with class, 包括我。 我们的目标是, 造一个很Java中的ThreadPool类似的线程池。目前的进度: [x] 极其简易的线程池(header only) [x] 支持设置线程池核心线程数 [ ] 支持设置线程池最大线程数 [ ] 支持设置最大缓存的任务数 [ ] 支持设置任务提交拒绝策略","text":"C++线程池 进程的创建和销毁,代价是昂贵的,除去操作系统的实现及其本身的原理,跟线程相比它更显得重量级。 这几年互联网的迅速发展,让线程正面临着跟进程一样的“重量级”困扰。尤其是GO等语言推出协程(纤程) 后,线程更是不堪其重。那么有没有改进的方向呢？有,将线程池化——线程池。 由于C++版本推进的历程(C++98, C++03, C++11, C++14, C++17, C++20)以及其 弱鸡般的ABI兼容性,导致很多框架用起来得自己造轮子。C++版本再吐槽一句好了, C++即使版本推进到 0xff, 对很多人来说还是c with class, 包括我。 我们的目标是, 造一个很Java中的ThreadPool类似的线程池。目前的进度: [x] 极其简易的线程池(header only) [x] 支持设置线程池核心线程数 [ ] 支持设置线程池最大线程数 [ ] 支持设置最大缓存的任务数 [ ] 支持设置任务提交拒绝策略 线程池中的概念: job: 需要在线程中执行的代码 例如: void read(const string &amp; path, const HANDLE handle); 该函数从文本中读取内容然后交给窗口渲染到界面上 task: 将job封装成一个task, 由于job的函数签名各异,所以需要封装(Java的job是Runnable,接口签名一致)。 例如: auto task = [=]()-&gt;void { return read(path, handle); } 这样就将签名各异的job统一封装成了std::function&lt;void()&gt;类型的task 通过std::packaged_task和std::future处理job被异步调用的返回值 queue: 缓存task的队列, 队列操作和线程池中的线程耦合度很高, 原因如下: 队列中的任务少时, 池中的空闲线程如何做到真正的不占用cpu? 目前此项目是通过std::condition_variable的条件判断让空闲线程阻塞从而让出cpu Java中是通过实现BlockQueue实现的,也就是队列中没有任务时,线程从队列中get会阻塞, 从而让出cpu 也可以通过信号量 互斥量实现 队列read write操作时, 可根据现实情况实现读优先、写优先的锁来平衡队列task的生产和消费, 目前此项目不支持 设置queue的最大缓存task数 为什么采取队列, 是为了保证task被执行的优先级(队列可以保证先提交的task被先执行,但是不保证先提交的task被先执行完) thread: 采用C++11 标准库中的std::thread 根据std::thread::hardware_concurrency()获取cpu数量进行任务cpu友好性优化, 目前此项目不支持 设置thread的cpu亲和性优化程序执行（Windows平台:通过SetThreadAffinityMask指定线程在cpu哪个核心上运行） Code Code On GitHub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#ifndef _THREAD_POOL_H#define _THREAD_POOL_H#include &lt;memory&gt;#include &lt;functional&gt;#include &lt;future&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;thread&gt;#include &lt;typeinfo&gt;/** * 几个需要注意的点: * 1、tasks的读写锁需要优化成带优先级的锁, 可以肯定线程池的绝大部分使用场景commit task比run task更密集 * 2、根据tasks以及cpu扩展线程数 * 3、支持允许缓存的task数,如果超出此数将采取拒绝策略 * 4、拒绝策略*/class ThreadPool&#123;public: ThreadPool(int core, int max = 0, int cache = 0): core(core),//由于max和cache暂时没用到,因此赋值0 max(max), cache(cache), quit(false), force(false)&#123; &#125; ~ThreadPool()&#123; this-&gt;quit.store(true); this-&gt;enable.notify_all(); std::for_each(this-&gt;pool.begin(), this-&gt;pool.end(), [](std::thread &amp; t)&#123; if(t.joinable())&#123; t.join(); &#125; &#125;); &#125;public: void start()&#123; for(auto idx = 0; idx &lt; core; ++idx)&#123; pool.push_back(std::thread([this]()&#123; // 第一次退出,判断是否要强制退出 bool quit = this-&gt;force.load() ? this-&gt;quit.load() : false; for(; !quit;)&#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;oper_lock); this-&gt;enable.wait(lock, [this]()&#123; return this-&gt;quit.load() || !this-&gt;tasks.empty(); &#125;); // 不是强制退出时可从这里退出 if(this-&gt;quit.load() &amp;&amp; this-&gt;tasks.empty())&#123; return; &#125; std::function&lt;void()&gt; task = std::move(this-&gt;tasks.front()); this-&gt;tasks.pop(); task(); &#125; &#125;)); &#125; &#125; void shutdown(bool force = false)&#123; this-&gt;quit.store(true); this-&gt;force.store(force); &#125; //void commit(std::function&lt;void (void * param)&gt; task); template&lt;class T, class... Args&gt; auto commit(T &amp;&amp; t, Args&amp;&amp;...args)-&gt;std::future&lt;decltype(t(args...))&gt;&#123; using TYPE = decltype(t(args...)); if(this-&gt;quit.load())&#123; //dont know return what, so throw an exception throw std::runtime_error(\"thread pool is alreay shutdown.\"); &#125; // 1、std::packaged_task&lt;decltype(f(args...))() 类似std::function\\ 但是会将其封装的可调用元素的结果封装在std::future中 // 2、std::make_shared 创建std::packaged_task&lt;decltype(f(args...))()\\ 类型的智能指针 // 3、std::bind(std::forward&lt;T&gt;(t), std::forward&lt;Args&gt;(args)...)当做\\ std::packaged_task的构造参数 auto task = std::make_shared&lt;std::packaged_task&lt;TYPE()&gt; &gt;( std::bind(std::forward&lt;T&gt;(t), std::forward&lt;Args&gt;(args)...) ); std::future&lt;TYPE&gt; result = task-&gt;get_future(); std::lock_guard&lt;std::mutex&gt; lock(this-&gt;oper_lock); //将packaged_task 包裹在一个签名为void()的lambda函数中调用,因为此lambda函数符合std::function&lt;void()&gt;\\ 的签名,所以可以放到queue中 this-&gt;tasks.emplace([task]()&#123; (*task)(); //调用packaged_task &#125;); this-&gt;enable.notify_one(); // 在线程池中唤醒一个休眠的线程 return result; &#125;private: //void move();private: std::vector&lt;std::thread&gt; pool; std::queue&lt;std::function&lt;void()&gt; &gt; tasks; int core; //线程池核心线程数 int max; //线程池根据tasks量以及cpu数最大可扩展的量 int cache; //运行tasks可缓存的最大task数,超出次数后commit将采取拒绝策略 std::atomic&lt;bool&gt; quit; //线程池shutdown条件, true时shutdown std::atomic&lt;bool&gt; force; //是否强制shutdown,true时有剩余的task将不执行直接退出, false时等待执行完所有的task再退出 std::condition_variable enable; // std::mutex oper_lock; // queue的读写锁&#125;;#endif Test Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;chrono&gt;#include \"./pool/ThreadPool.hpp\"int main(int argc, char** argv)&#123; ThreadPool pool(4); pool.start(); std::default_random_engine rd; std::uniform_int_distribution&lt;int&gt; rang(100, 1000); for(int idx = 0; idx &lt; 20; ++idx)&#123; pool.commit([=](int x, int y, int t)&#123; std::cout &lt;&lt; \"thread id : \" &lt;&lt; std::this_thread::get_id() &lt;&lt; \" x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; \" sleep time = \" &lt;&lt; t &lt;&lt; \" ms\" &lt;&lt; \" id = \" &lt;&lt; idx &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(t)); &#125;, rang(rd), rang(rd), rang(rd)); &#125; std::vector&lt;std::future&lt;int&gt; &gt; results; for (auto index = 20; index &lt; 50; ++index)&#123; results.push_back( pool.commit([=]()-&gt;int&#123; return index; &#125;) ); &#125; for ( auto &amp; r : results)&#123; std::cout &lt;&lt; \"get result from thread \" &lt;&lt; \" index = \" &lt;&lt; r.get() &lt;&lt; std::endl; &#125; char command = std::cin.get(); if (command == 'q')&#123; pool.shutdown(true); &#125;else if (command == 'e')&#123; pool.shutdown(true); try &#123; pool.commit([]()&#123; std::cout &lt;&lt; \"i want to get an exception\" &lt;&lt; std::endl; &#125;); &#125; catch(const std::exception&amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; '\\n'; &#125; &#125; std::cout &lt;&lt; \"test finish, OY!\" &lt;&lt; std::endl; return 0;&#125; Compile &amp; Link 1g++ -g -O3 -Wall -std=c++11 main.cpp -o ./out/test Run 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253thread id : 0x70000a352000 x = 242 y = 937 sleep time = 480 ms id = 0thread id : 0x70000a352000 x = 340 y = 390 sleep time = 692 ms id = 1thread id : 0x70000a352000 x = 188 y = 294 sleep time = 738 ms id = 2thread id : 0x70000a352000 x = 390 y = 978 sleep time = 270 ms id = 3thread id : 0x70000a4db000 x = 432 y = 780 sleep time = 102 ms id = 4thread id : 0x70000a458000 x = 652 y = 661 sleep time = 498 ms id = 5thread id : 0x70000a3d5000 x = 839 y = 452 sleep time = 487 ms id = 6thread id : 0x70000a352000 x = 698 y = 540 sleep time = 183 ms id = 7thread id : 0x70000a4db000 x = 157 y = 983 sleep time = 638 ms id = 8thread id : 0x70000a3d5000 x = 232 y = 823 sleep time = 766 ms id = 9thread id : 0x70000a458000 x = 801 y = 411 sleep time = 314 ms id = 10thread id : 0x70000a458000 x = 359 y = 912 sleep time = 294 ms id = 11thread id : 0x70000a458000 x = 260 y = 142 sleep time = 372 ms id = 12thread id : 0x70000a458000 x = 618 y = 499 sleep time = 831 ms id = 13thread id : 0x70000a458000 x = 108 y = 319 sleep time = 376 ms id = 14thread id : 0x70000a3d5000 x = 870 y = 490 sleep time = 519 ms id = 15thread id : 0x70000a352000 x = 446 y = 998 sleep time = 496 ms id = 16thread id : 0x70000a3d5000 x = 321 y = 308 sleep time = 610 ms id = 17thread id : 0x70000a3d5000 x = 247 y = 256 sleep time = 629 ms id = 18thread id : 0x70000a3d5000 x = 186 y = 484 sleep time = 703 ms id = 19get result from thread index = 20get result from thread index = 21get result from thread index = 22get result from thread index = 23get result from thread index = 24get result from thread index = 25get result from thread index = 26get result from thread index = 27get result from thread index = 28get result from thread index = 29get result from thread index = 30get result from thread index = 31get result from thread index = 32get result from thread index = 33get result from thread index = 34get result from thread index = 35get result from thread index = 36get result from thread index = 37get result from thread index = 38get result from thread index = 39get result from thread index = 40get result from thread index = 41get result from thread index = 42get result from thread index = 43get result from thread index = 44get result from thread index = 45get result from thread index = 46get result from thread index = 47get result from thread index = 48get result from thread index = 49ethread pool is alreay shutdown.test finish, OY!","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"http://www.zhangyebai.com/categories/FrameWork/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.zhangyebai.com/tags/C/"},{"name":"线程","slug":"线程","permalink":"http://www.zhangyebai.com/tags/线程/"},{"name":"线程池","slug":"线程池","permalink":"http://www.zhangyebai.com/tags/线程池/"}]},{"title":"LeetCode - 053 - Maximum-Sub-Array","slug":"maximum-sub-array","date":"2019-02-12T13:37:45.000Z","updated":"2019-02-12T14:45:46.080Z","comments":true,"path":"2019/02/12/maximum-sub-array/","link":"","permalink":"http://www.zhangyebai.com/2019/02/12/maximum-sub-array/","excerpt":"Description 官方地址 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法…… 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。","text":"Description 官方地址 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法…… 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。 Java Solution code ✔ Accepted ✔ 202/202 cases passed (16 ms) ✔ Your runtime beats 31.02 % of java submissions ✔ 2019-02-12 21:31:45 123456789101112131415class Solution &#123; public int maxSubArray(int[] nums) &#123; if (nums.length == 0)&#123; return 0; &#125; int sum = nums[0]; //sum保存着跟随idx遍历nums每个索引为结束位置的最大值（不是太好理解） int max = nums[0]; //max保存着idx及其以前的元素为结束位置的最大值 for ( int idx = 1; idx &lt; nums.length; ++idx)&#123; //注意idx从1开始,因为sum和max不能初始化为0, //只能初始化为nums[0],因为nums中的元素可能是负数 sum = Math.max(sum + nums[idx], nums[idx]); //注意sum是以idx索引元素为结束位置的最大值（包含idx） max = Math.max(sum, max); // &#125; return max; &#125;&#125; (max: 全局的最大值,也就是我们要求的结果; sum: 局部最大值,代表的是以某元素结尾的最大值) -1 2 -3 4 -1 idx = 0: sum = -1, max = -1 (注: 此步骤即是初始化sum和max, 也就是第一个元素为结尾的局部最大值和全局最大值) idx = 1: sum = (-1 + 2), max = sum = 1 idx = 2: sum = (1 + -3), max = 1 idx = 3: sum = 4, max = sum = 4 idx = 4: sum = (4 + -1), max = 4 所以求得结果max=4 注意到此题有dp解法,后续增加","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhangyebai.com/categories/LeetCode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhangyebai.com/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"}]},{"title":"LeetCode - 002 - Add Two Numbers (Medium)","slug":"add-two-numbers","date":"2017-02-19T07:08:44.000Z","updated":"2019-02-12T14:51:34.444Z","comments":true,"path":"2017/02/19/add-two-numbers/","link":"","permalink":"http://www.zhangyebai.com/2017/02/19/add-two-numbers/","excerpt":"Descripiton You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。 这句话什么意思呢？换句话说就是这样： 比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4); 19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1); 因为表示顺序是反着的，所以进位也是反着的。 假设这两个数字不包含任何的头结点0，除了数字0本身。 Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8","text":"Descripiton You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。 这句话什么意思呢？换句话说就是这样： 比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4); 19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1); 因为表示顺序是反着的，所以进位也是反着的。 假设这两个数字不包含任何的头结点0，除了数字0本身。 Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Solution 通过描述中的大致分析可以看出，需要遍历两个Linked-List中的对应的Node并取数相加，然后生成新Node并添加到result的Link-List中。 - 2个Linked-List中对应的Node，如果有一个为null，一个不为null，则结果节点直接使用不为null的Node中的值去构造即可; - 如果两个Node相加需要进位，切记是向后进位，如果有后续Node，计算是需要加上进位; - 如果两个Node相加需要进位，且没有后续Node，则需要添加一个Node，值用进位的数即可; - 以下代码截止到提交日期，均已被LeetCode AC； Python Solution code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env python# _*_ coding:utf-8 _*_#Node定义class ListNode(object): def __init__(self, x): self.val = x self.next = None#LeetCode的命名规范我已经无力吐槽了class Solution(object): def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" result = ListNode(0) step = result l_hand, r_hand = l1, l2 node_sum = 0 while l_hand is not None or r_hand is not None: node_sum //= 10 if l_hand is not None: node_sum += l_hand.val l_hand = l_hand.next if r_hand is not None: node_sum += r_hand.val r_hand = r_hand.next step.next = ListNode(node_sum % 10) step = step.next if node_sum // 10 &gt; 0: step.next = ListNode(1) return result.next#TestCasedef init_node(param)-&gt;ListNode: result_node, temp_node = None, None for value in param: if result_node is None: temp_node = ListNode(value) result_node = temp_node continue temp_node.next = ListNode(value) temp_node = temp_node.next return result_nodedef print_node(param_node: ListNode)-&gt;None: temp_node, values = param_node, [] while temp_node is not None: values.append(str(temp_node.val)) temp_node = temp_node.next print('[', '-&gt;'.join(values), ']', sep=None)if __name__ == '__main__': l_node = init_node([3, 7]) r_node = init_node([9, 2]) print_node(Solution().add_two_nums(l_node, r_node)) Java Solution code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode result = new ListNode(0); ListNode step = result; ListNode l_hand = l1; ListNode r_hand = l2; int node_sum = 0; for(;l_hand != null || r_hand != null;)&#123; node_sum /= 10; if (l_hand != null)&#123; node_sum += l_hand.val; l_hand = l_hand.next; &#125; if (r_hand !=null)&#123; node_sum += r_hand.val; r_hand = r_hand.next; &#125; step.next = new ListNode(node_sum % 10); step = step.next; &#125; if (node_sum / 10 &gt; 0)&#123; step.next = new ListNode(1); &#125; return result.next; &#125; //TestCase public static void printNode(ListNode node)&#123; while (node != null)&#123; System.out.println(node.val); node = node.next; &#125; &#125; public static void main(String[] args)&#123; //不要问我这两个数组时哪里来的，没有错误的程序是不会知道的 int[] arr1 = &#123;1,6,6,0,5,8,1,0,7&#125;; int[] arr2 = &#123;8,2,5,7,9,1,0,2,2,1&#125;; printNode(new AddTwoNumbers().addTwoNumbers(initList(arr1), initList(arr2))); &#125;&#125;class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; C++ Solution code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#ifndef NULL#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif#endifstruct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125; &#125;;class AddTwoNumbers &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode head(0); ListNode *step = &amp;head, *l_hand = l1, *r_hand = l2; int node_sum = 0; for (; l_hand || r_hand;) &#123; node_sum /= 10; if (l_hand) &#123; node_sum += l_hand-&gt;val; l_hand = l_hand-&gt;next; &#125; if (r_hand) &#123; node_sum += r_hand-&gt;val; r_hand = r_hand-&gt;next; &#125; step-&gt;next = new ListNode(node_sum % 10); step = step-&gt;next; &#125; if (node_sum / 10 &gt; 0) &#123; step-&gt;next = new ListNode(1); &#125; return head.next; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhangyebai.com/categories/LeetCode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhangyebai.com/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"},{"name":"Python","slug":"Python","permalink":"http://www.zhangyebai.com/tags/Python/"},{"name":"C++","slug":"C","permalink":"http://www.zhangyebai.com/tags/C/"}]},{"title":"Singleton - 单例模式 - Java","slug":"Singleton","date":"2017-02-13T15:48:30.000Z","updated":"2019-02-12T14:42:52.315Z","comments":true,"path":"2017/02/13/Singleton/","link":"","permalink":"http://www.zhangyebai.com/2017/02/13/Singleton/","excerpt":"单例模式 One instance of a class or one value accessible globally in an application. Ensure that only one instance of a class is created. Provide a global point of access to the object. 在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点: 确保该唯一实例被创建。 为外界使用该实例提供一个全局的访问入口。 对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。","text":"单例模式 One instance of a class or one value accessible globally in an application. Ensure that only one instance of a class is created. Provide a global point of access to the object. 在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点: 确保该唯一实例被创建。 为外界使用该实例提供一个全局的访问入口。 对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。 简单懒汉式单例模式 - 简单 * 3，但是致命缺点是线程不安全。 - 懒汉式:在Singleton被ClassLoader加载时并不实例化instance，只有在需要时(即调用getInstance方法时)才会触发实例化。 - getInstance，newInstance在命名规范上的区别是分别对应单例和多例! code 123456789101112131415161718192021222324252627282930313233343536373839404142public class Singleton implements java.io.Serializable &#123; private static Singleton instance; private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次 3mspublic static void testRuntime()&#123; long timestart = System.currentTimeMillis(); for (int index = 0, loop = 10000000; index &lt; loop; ++index)&#123; Singleton singletonThread1 = Singleton.getSingletonInstance(); &#125; &#125; long timeend = System.currentTimeMillis(); System.out.println(timeend - timestart);&#125;//MultipleInstanceTestCaseclass MultipleTest implements Runnable&#123; public Map&lt;Singleton, Integer&gt; hMap = new Hashtable&lt;&gt;(); @Override public void run() &#123; Singleton singleton = Singleton.getSingletonInstance(); hMap.put(singleton, 0); &#125; &#125;/*开启了100000个线程测试，并未发现有多个实例的现象，但是此种做法确实是存在多例的风险，原因在于当两个线程同时调用 getSingletonInstance()且instance都为null时，两个线程可能会同时执行instance = new Singleton();*/ 线程安全懒汉式单例模式 - 通过对全局入口方法加同步来解决线程安全的问题。 - 带来的后果是资源的开销是非常大的，因为初始化完instance后不再需要synchronized - 毕竟线程安全了。 code 1234567891011121314151617181920212223public class Singleton implements java.io.Serializable &#123; private static Singleton instance; private Singleton()&#123; &#125; public static synchroized Singleton getSingletonInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次调用 56ms （简单懒汉式单例模式中为3ms）//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 改进效率版懒汉式单例模式 - synchroized 同步方法的资源开销是很大的。 - 改进点在于用synchronized同步实例化代码块，这样的好处是一旦实例化完成，以后的调用不会再触碰到synchronized。 code 123456789101112131415161718192021222324252627public class Singleton implements java.io.Serializable&#123; private volatile static Singleton instance; private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; if (instance == null)&#123; synchroized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次调用 3ms 理论上来说应该于 简单懒汉式单例模式 中的实现效率持平。//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 饿汉式单例模式 - 触发ClassLoader加载该类时实例化。 - 与懒汉式的区别是:主动实例化。 code 12345678910111213141516171819202122232425262728293031323334353637public class Singleton implements java.io.Serializable&#123; private static Singleton instance = new Singleton(); private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//另一种写法是通过静态代码块实例化public class Singleton implements java.io.Serializable&#123; private static Singleton instance; static&#123; instance = new Singleton(); &#125; private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次调用 2ms。//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 静态内部类实现单例 - 实现延迟实例化。 - 线程安全。 - 推荐使用。 code 12345678910111213141516171819public class Singleton implements java.io.Serializable&#123; private static class SingletonController&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getSingletonInstance()&#123; return SingletonController.instance; &#125; private Object readResolve()&#123; return SingletonController.instance;; &#125;&#125;//RuntimeTestCase 10000000次调用 3ms 。//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 枚举实现 最近在看《Effective java 中文版2th》的时候，看到的此种方法，顿时被惊呆。以下为书中原话: - since jdk 1.5 。 - 只需编写一个包含单个元素的枚举类型即可实现。 - 此方法在功能上与公有域方法接近，但是它更加简洁，无偿地提供了序列化机制。 - 绝对的防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。 - 虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。 code 1234public enum Singleton&#123; INSTANCE; //代码至此已经完事。&#125;","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://www.zhangyebai.com/categories/Design-Pattern/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.zhangyebai.com/tags/设计模式/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://www.zhangyebai.com/tags/Design-Pattern/"}]},{"title":"LeetCode - 001 - Two Sum (Easy)","slug":"two-sum","date":"2017-02-12T21:02:51.000Z","updated":"2019-02-12T14:51:39.055Z","comments":true,"path":"2017/02/13/two-sum/","link":"","permalink":"http://www.zhangyebai.com/2017/02/13/two-sum/","excerpt":"Descripiton Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。 假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。 Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].","text":"Descripiton Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。 假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。 Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Solution 利用map数据结构的Key-Value键值对的存储特点，遍历array数组时，查看当前数组元素value与目标target的差（target - value）是否在map的keys中，如果存在说明前面的遍历时找到了第一个value，取出索引并返回当前索引即可;如果没找到，将当前value作为key，当前索引index作为key的value放置进map继续遍历即可。 Python中map数据结构为字典（dict） 适当关注一下c++中std::map和std::vector的相关操作 以下代码截止到提交日期，均已被LeetCode AC Python Solution code 123456789101112131415161718192021#!/usr/bin/env python# _*_ coding:utf-8 _*_class Solution(object): def two_num(nums, target)-&gt;object: nums_dict = &#123;&#125; for loop, value in enumerate(nums): if nums_dict.__contains__(target - value): return [nums_dict[target - value], loop] else: nums_dict[value] = loop#TestCaseif __name__ == '__main__': num_list = [2, 7, 11, 15] target_num = 22 result = Solution().two_num(num_list, target_num) try: for index in result: print('-&gt;'.join([str(index), str(num_list[index])])) except TypeError: print('no target to find') Java Solution code 123456789101112131415public class Solution&#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&amp;ltInteger, Integer&gt; map = new HashMap&amp;ltInteger, Integer&gt;(); for(int index = 0, length = nums.length; index &lt; length; ++index)&#123; if (map.containsKey(target - nums[index]))&#123; result[0] = map.get(target - nums[index]); result[1] = index; &#125;else&#123; map.put(nums[index], index); &#125; &#125; return result; &#125;&#125; C++ Solution code 123456789101112131415161718192021222324252627282930313233343536#include &lt;vector&gt;#include &lt;map&gt;class Solution &#123;public: std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt;&amp; nums, int target) &#123; std::vector&lt;int&gt; result; std::map&lt;int, int&gt; loop; for (std::size_t index = 0; index &lt; nums.size(); ++index) &#123; if (loop.find(target - nums.at(index)) != loop.cend()) &#123; result.push_back(loop.at(target - nums.at(index))); result.push_back(index); &#125; else &#123; loop.insert(std::map&lt;int, int&gt;::value_type(nums.at(index), index)); &#125; &#125; return result; &#125;&#125;;//TestCase#include &lt;iostream&gt;int main()&#123; Solution solution; std::vector&lt;int&gt; nums = &#123; 2, 7, 11, 15 &#125;; std::vector&lt;int&gt; result = solution.twoSum(nums, 9); for(std::vector&lt;int&gt;::iterator iter = result.begin(); iter != result.end(); ++iter) std::cout &lt;&lt; *iter &lt;&lt; std::endl; int timing = 0; std::cin &gt;&gt; timing; return 0;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhangyebai.com/categories/LeetCode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhangyebai.com/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"},{"name":"Python","slug":"Python","permalink":"http://www.zhangyebai.com/tags/Python/"},{"name":"C++","slug":"C","permalink":"http://www.zhangyebai.com/tags/C/"}]}]}