{"meta":{"title":"一码平川","subtitle":null,"description":null,"author":"张夜白","url":"http://www.zhangyebai.com"},"pages":[{"title":"categories","date":"2019-02-12T09:26:15.000Z","updated":"2019-02-12T09:30:58.238Z","comments":true,"path":"categories/index.html","permalink":"http://www.zhangyebai.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-02-12T09:26:01.000Z","updated":"2019-02-12T09:30:44.034Z","comments":true,"path":"tags/index.html","permalink":"http://www.zhangyebai.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-02-12T09:52:52.000Z","updated":"2019-02-12T09:58:13.812Z","comments":true,"path":"about/index.html","permalink":"http://www.zhangyebai.com/about/index.html","excerpt":"","text":"张夜白 GitHub 北京 29"}],"posts":[{"title":"LeetCode - 053 - Maximum-Sub-Array","slug":"maximum-sub-array","date":"2019-02-12T13:37:45.000Z","updated":"2019-02-12T14:39:39.156Z","comments":true,"path":"2019/02/12/maximum-sub-array/","link":"","permalink":"http://www.zhangyebai.com/2019/02/12/maximum-sub-array/","excerpt":"Description 官方地址 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法…… 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。","text":"Description 官方地址 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法…… 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。 Java Solution code ✔ Accepted ✔ 202/202 cases passed (16 ms) ✔ Your runtime beats 31.02 % of java submissions ✔ 2019-02-12 21:31:45 12345678910111213141516class Solution &#123; public int maxSubArray(int[] nums) &#123; if (nums.length == 0)&#123; return 0; &#125; int sum = nums[0]; //sum保存着跟随idx遍历nums每个索引为结束位置的最大值（不是太好理解） int max = nums[0]; //max保存着idx及其以前的元素为结束位置的最大值 for ( int idx = 1; idx &lt; nums.length; ++idx)&#123; //注意idx从1开始,因为sum和max不能初始化为0, //只能初始化为nums[0],因为nums中的元素可能是负数 sum = Math.max(sum + nums[idx], nums[idx]); //注意sum是以idx索引元素为结束位置的最大值（包含idx） max = Math.max(sum, max); // &#125; return max; &#125;&#125; (max: 全局的最大值,也就是我们要求的结果; sum: 局部最大值,代表的是以某元素结尾的最大值) -1 2 -3 4 -1 idx = 0: sum = -1, max = -1 (注: 此步骤即是初始化sum和max, 也就是第一个元素为结尾的局部最大值和全局最大值) idx = 1: sum = (-1 + 2), max = sum = 1 idx = 2: sum = (1 + -3), max = 1 idx = 3: sum = 4, max = sum = 4 idx = 4: sum = (4 + -1), max = 4 所以求得结果max=4 注意到此题有dp解法,后续增加","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhangyebai.com/categories/LeetCode/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"},{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhangyebai.com/tags/leetcode/"}]},{"title":"LeetCode - 002 - Add Two Numbers (Medium)","slug":"add-two-numbers","date":"2017-02-19T07:08:44.000Z","updated":"2019-02-12T14:44:10.529Z","comments":true,"path":"2017/02/19/add-two-numbers/","link":"","permalink":"http://www.zhangyebai.com/2017/02/19/add-two-numbers/","excerpt":"Descripiton You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。 这句话什么意思呢？换句话说就是这样： 比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4); 19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1); 因为表示顺序是反着的，所以进位也是反着的。 假设这两个数字不包含任何的头结点0，除了数字0本身。 Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8","text":"Descripiton You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。 这句话什么意思呢？换句话说就是这样： 比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4); 19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1); 因为表示顺序是反着的，所以进位也是反着的。 假设这两个数字不包含任何的头结点0，除了数字0本身。 Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Solution 通过描述中的大致分析可以看出，需要遍历两个Linked-List中的对应的Node并取数相加，然后生成新Node并添加到result的Link-List中。 - 2个Linked-List中对应的Node，如果有一个为null，一个不为null，则结果节点直接使用不为null的Node中的值去构造即可; - 如果两个Node相加需要进位，切记是向后进位，如果有后续Node，计算是需要加上进位; - 如果两个Node相加需要进位，且没有后续Node，则需要添加一个Node，值用进位的数即可; - 以下代码截止到提交日期，均已被LeetCode AC； Python Solution code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env python# _*_ coding:utf-8 _*_#Node定义class ListNode(object): def __init__(self, x): self.val = x self.next = None#LeetCode的命名规范我已经无力吐槽了class Solution(object): def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" result = ListNode(0) step = result l_hand, r_hand = l1, l2 node_sum = 0 while l_hand is not None or r_hand is not None: node_sum //= 10 if l_hand is not None: node_sum += l_hand.val l_hand = l_hand.next if r_hand is not None: node_sum += r_hand.val r_hand = r_hand.next step.next = ListNode(node_sum % 10) step = step.next if node_sum // 10 &gt; 0: step.next = ListNode(1) return result.next#TestCasedef init_node(param)-&gt;ListNode: result_node, temp_node = None, None for value in param: if result_node is None: temp_node = ListNode(value) result_node = temp_node continue temp_node.next = ListNode(value) temp_node = temp_node.next return result_nodedef print_node(param_node: ListNode)-&gt;None: temp_node, values = param_node, [] while temp_node is not None: values.append(str(temp_node.val)) temp_node = temp_node.next print('[', '-&gt;'.join(values), ']', sep=None)if __name__ == '__main__': l_node = init_node([3, 7]) r_node = init_node([9, 2]) print_node(Solution().add_two_nums(l_node, r_node)) Java Solution code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode result = new ListNode(0); ListNode step = result; ListNode l_hand = l1; ListNode r_hand = l2; int node_sum = 0; for(;l_hand != null || r_hand != null;)&#123; node_sum /= 10; if (l_hand != null)&#123; node_sum += l_hand.val; l_hand = l_hand.next; &#125; if (r_hand !=null)&#123; node_sum += r_hand.val; r_hand = r_hand.next; &#125; step.next = new ListNode(node_sum % 10); step = step.next; &#125; if (node_sum / 10 &gt; 0)&#123; step.next = new ListNode(1); &#125; return result.next; &#125; //TestCase public static void printNode(ListNode node)&#123; while (node != null)&#123; System.out.println(node.val); node = node.next; &#125; &#125; public static void main(String[] args)&#123; //不要问我这两个数组时哪里来的，没有错误的程序是不会知道的 int[] arr1 = &#123;1,6,6,0,5,8,1,0,7&#125;; int[] arr2 = &#123;8,2,5,7,9,1,0,2,2,1&#125;; printNode(new AddTwoNumbers().addTwoNumbers(initList(arr1), initList(arr2))); &#125;&#125;class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; C++ Solution code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#ifndef NULL#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif#endifstruct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125; &#125;;class AddTwoNumbers &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode head(0); ListNode *step = &amp;head, *l_hand = l1, *r_hand = l2; int node_sum = 0; for (; l_hand || r_hand;) &#123; node_sum /= 10; if (l_hand) &#123; node_sum += l_hand-&gt;val; l_hand = l_hand-&gt;next; &#125; if (r_hand) &#123; node_sum += r_hand-&gt;val; r_hand = r_hand-&gt;next; &#125; step-&gt;next = new ListNode(node_sum % 10); step = step-&gt;next; &#125; if (node_sum / 10 &gt; 0) &#123; step-&gt;next = new ListNode(1); &#125; return head.next; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhangyebai.com/categories/LeetCode/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"},{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhangyebai.com/tags/leetcode/"},{"name":"Python","slug":"Python","permalink":"http://www.zhangyebai.com/tags/Python/"},{"name":"C++","slug":"C","permalink":"http://www.zhangyebai.com/tags/C/"}]},{"title":"Singleton - 单例模式 - Java","slug":"Singleton","date":"2017-02-13T15:48:30.000Z","updated":"2019-02-12T14:42:52.315Z","comments":true,"path":"2017/02/13/Singleton/","link":"","permalink":"http://www.zhangyebai.com/2017/02/13/Singleton/","excerpt":"单例模式 One instance of a class or one value accessible globally in an application. Ensure that only one instance of a class is created. Provide a global point of access to the object. 在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点: 确保该唯一实例被创建。 为外界使用该实例提供一个全局的访问入口。 对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。","text":"单例模式 One instance of a class or one value accessible globally in an application. Ensure that only one instance of a class is created. Provide a global point of access to the object. 在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点: 确保该唯一实例被创建。 为外界使用该实例提供一个全局的访问入口。 对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。 简单懒汉式单例模式 - 简单 * 3，但是致命缺点是线程不安全。 - 懒汉式:在Singleton被ClassLoader加载时并不实例化instance，只有在需要时(即调用getInstance方法时)才会触发实例化。 - getInstance，newInstance在命名规范上的区别是分别对应单例和多例! code 123456789101112131415161718192021222324252627282930313233343536373839404142public class Singleton implements java.io.Serializable &#123; private static Singleton instance; private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次 3mspublic static void testRuntime()&#123; long timestart = System.currentTimeMillis(); for (int index = 0, loop = 10000000; index &lt; loop; ++index)&#123; Singleton singletonThread1 = Singleton.getSingletonInstance(); &#125; &#125; long timeend = System.currentTimeMillis(); System.out.println(timeend - timestart);&#125;//MultipleInstanceTestCaseclass MultipleTest implements Runnable&#123; public Map&lt;Singleton, Integer&gt; hMap = new Hashtable&lt;&gt;(); @Override public void run() &#123; Singleton singleton = Singleton.getSingletonInstance(); hMap.put(singleton, 0); &#125; &#125;/*开启了100000个线程测试，并未发现有多个实例的现象，但是此种做法确实是存在多例的风险，原因在于当两个线程同时调用 getSingletonInstance()且instance都为null时，两个线程可能会同时执行instance = new Singleton();*/ 线程安全懒汉式单例模式 - 通过对全局入口方法加同步来解决线程安全的问题。 - 带来的后果是资源的开销是非常大的，因为初始化完instance后不再需要synchronized - 毕竟线程安全了。 code 1234567891011121314151617181920212223public class Singleton implements java.io.Serializable &#123; private static Singleton instance; private Singleton()&#123; &#125; public static synchroized Singleton getSingletonInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次调用 56ms （简单懒汉式单例模式中为3ms）//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 改进效率版懒汉式单例模式 - synchroized 同步方法的资源开销是很大的。 - 改进点在于用synchronized同步实例化代码块，这样的好处是一旦实例化完成，以后的调用不会再触碰到synchronized。 code 123456789101112131415161718192021222324252627public class Singleton implements java.io.Serializable&#123; private volatile static Singleton instance; private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; if (instance == null)&#123; synchroized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次调用 3ms 理论上来说应该于 简单懒汉式单例模式 中的实现效率持平。//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 饿汉式单例模式 - 触发ClassLoader加载该类时实例化。 - 与懒汉式的区别是:主动实例化。 code 12345678910111213141516171819202122232425262728293031323334353637public class Singleton implements java.io.Serializable&#123; private static Singleton instance = new Singleton(); private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//另一种写法是通过静态代码块实例化public class Singleton implements java.io.Serializable&#123; private static Singleton instance; static&#123; instance = new Singleton(); &#125; private Singleton()&#123; &#125; public static Singleton getSingletonInstance()&#123; return instance; &#125; private Object readResolve()&#123; return instance; &#125;&#125;//RuntimeTestCase 10000000次调用 2ms。//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 静态内部类实现单例 - 实现延迟实例化。 - 线程安全。 - 推荐使用。 code 12345678910111213141516171819public class Singleton implements java.io.Serializable&#123; private static class SingletonController&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getSingletonInstance()&#123; return SingletonController.instance; &#125; private Object readResolve()&#123; return SingletonController.instance;; &#125;&#125;//RuntimeTestCase 10000000次调用 3ms 。//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。 枚举实现 最近在看《Effective java 中文版2th》的时候，看到的此种方法，顿时被惊呆。以下为书中原话: - since jdk 1.5 。 - 只需编写一个包含单个元素的枚举类型即可实现。 - 此方法在功能上与公有域方法接近，但是它更加简洁，无偿地提供了序列化机制。 - 绝对的防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。 - 虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。 code 1234public enum Singleton&#123; INSTANCE; //代码至此已经完事。&#125;","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://www.zhangyebai.com/categories/Design-Pattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.zhangyebai.com/tags/设计模式/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://www.zhangyebai.com/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"}]},{"title":"LeetCode - 001 - Two Sum (Easy)","slug":"two-sum","date":"2017-02-12T21:02:51.000Z","updated":"2019-02-12T14:44:01.705Z","comments":true,"path":"2017/02/13/two-sum/","link":"","permalink":"http://www.zhangyebai.com/2017/02/13/two-sum/","excerpt":"Descripiton Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。 假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。 Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].","text":"Descripiton Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。 假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。 Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Solution 利用map数据结构的Key-Value键值对的存储特点，遍历array数组时，查看当前数组元素value与目标target的差（target - value）是否在map的keys中，如果存在说明前面的遍历时找到了第一个value，取出索引并返回当前索引即可;如果没找到，将当前value作为key，当前索引index作为key的value放置进map继续遍历即可。 Python中map数据结构为字典（dict） 适当关注一下c++中std::map和std::vector的相关操作 以下代码截止到提交日期，均已被LeetCode AC Python Solution code 123456789101112131415161718192021#!/usr/bin/env python# _*_ coding:utf-8 _*_class Solution(object): def two_num(nums, target)-&gt;object: nums_dict = &#123;&#125; for loop, value in enumerate(nums): if nums_dict.__contains__(target - value): return [nums_dict[target - value], loop] else: nums_dict[value] = loop#TestCaseif __name__ == '__main__': num_list = [2, 7, 11, 15] target_num = 22 result = Solution().two_num(num_list, target_num) try: for index in result: print('-&gt;'.join([str(index), str(num_list[index])])) except TypeError: print('no target to find') Java Solution code 123456789101112131415public class Solution&#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&amp;ltInteger, Integer&gt; map = new HashMap&amp;ltInteger, Integer&gt;(); for(int index = 0, length = nums.length; index &lt; length; ++index)&#123; if (map.containsKey(target - nums[index]))&#123; result[0] = map.get(target - nums[index]); result[1] = index; &#125;else&#123; map.put(nums[index], index); &#125; &#125; return result; &#125;&#125; C++ Solution code 123456789101112131415161718192021222324252627282930313233343536#include &amp;lt;vector&gt;#include &amp;lt;map&gt;class Solution &#123;public: std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt;&amp; nums, int target) &#123; std::vector&lt;int&gt; result; std::map&lt;int, int&gt; loop; for (std::size_t index = 0; index &lt; nums.size(); ++index) &#123; if (loop.find(target - nums.at(index)) != loop.cend()) &#123; result.push_back(loop.at(target - nums.at(index))); result.push_back(index); &#125; else &#123; loop.insert(std::map&lt;int, int&gt;::value_type(nums.at(index), index)); &#125; &#125; return result; &#125;&#125;;//TestCase#include &amp;lt;iostream&gt;int main()&#123; Solution solution; std::vector&lt;int&gt; nums = &#123; 2, 7, 11, 15 &#125;; std::vector&lt;int&gt; result = solution.twoSum(nums, 9); for(std::vector&lt;int&gt;::iterator iter = result.begin(); iter != result.end(); ++iter) std::cout &lt;&lt; *iter &lt;&lt; std::endl; int timing = 0; std::cin &gt;&gt; timing; return 0;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhangyebai.com/categories/LeetCode/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhangyebai.com/tags/Java/"},{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhangyebai.com/tags/leetcode/"},{"name":"Python","slug":"Python","permalink":"http://www.zhangyebai.com/tags/Python/"},{"name":"C++","slug":"C","permalink":"http://www.zhangyebai.com/tags/C/"}]}]}