<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一码平川</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhangyebai.com/"/>
  <updated>2019-02-14T09:06:47.724Z</updated>
  <id>http://www.zhangyebai.com/</id>
  
  <author>
    <name>张夜白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手写线程池 modern-cpluscplus-threadpool</title>
    <link href="http://www.zhangyebai.com/2019/02/14/modern-cpluscplus-threadpool/"/>
    <id>http://www.zhangyebai.com/2019/02/14/modern-cpluscplus-threadpool/</id>
    <published>2019-02-14T06:38:00.000Z</published>
    <updated>2019-02-14T09:06:47.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c线程池"><a class="markdownIt-Anchor" href="#c线程池"></a> C++线程池</h2><blockquote><p>进程的创建和销毁,代价是昂贵的,除去操作系统的实现及其本身的原理,跟线程相比它更显得重量级。<br>这几年互联网的迅速发展,让线程正面临着跟进程一样的“重量级”困扰。尤其是GO等语言退出协程(纤程)<br>后,线程更是不堪其重。那么有没有改进的方向呢？有,将线程池化——线程池。</p></blockquote><p>由于C++版本推进的历程(<code>C++98</code>, <code>C++03</code>, <code>C++11</code>, <code>C++14</code>, <code>C++17</code>, <code>C++20</code>)以及其<br>弱鸡般的ABI兼容性,导致很多框架用起来得自己造轮子。C++版本再吐槽一句好了, C++即使版本推进到<br>0xff, 对很多人来说还是c with class, 包括我。<br>我们的目标是, 造一个很Java中的ThreadPool类似的线程池。目前的进度:</p><ul><li>[x] 极其简易的线程池(header only)</li><li>[x] 支持设置线程池核心线程数</li><li>[ ] 支持设置线程池最大线程数</li><li>[ ] 支持设置最大缓存的任务数</li><li>[ ] 支持设置任务提交拒绝策略</li></ul><a id="more"></a><p>线程池中的概念:</p><ul><li>job: 需要在线程中执行的代码<ul><li>例如: void read(const string &amp; path, const HANDLE handle);</li><li>该函数从文本中读取内容然后交给窗口渲染到界面上</li></ul></li><li>task: 将job封装成一个task, 由于job的函数签名各异,所以需要封装(Java的job是Runnable,接口签名一致)。<ul><li>例如: auto task = [=]()-&gt;void { return read(path, handle); }</li><li>这样就将签名各异的job统一封装成了std::function&lt;void()&gt;类型的task</li><li>通过std::packaged_task和std::future处理job被异步调用的返回值</li></ul></li><li>queue: 缓存task的队列, 队列操作和线程池中的线程耦合度很高, 原因如下:<ul><li>队列中的任务少时, 池中的空闲线程如何做到真正的不占用cpu?<ul><li>目前此项目是通过std::condition_variable的条件判断让空闲线程阻塞从而让出cpu</li><li>Java中是通过实现BlockQueue实现的,也就是队列中没有任务时,线程从队列中get会阻塞, 从而让出cpu</li><li>也可以通过信号量 互斥量实现</li></ul></li><li>队列read write操作时, 可根据现实情况实现读优先、写优先的锁来平衡队列task的生产和消费, 目前此项目不支持</li><li>设置queue的最大缓存task数</li><li>为什么采取队列, 是为了保证task被执行的优先级(队列可以保证先提交的task被先执行,但是不保证先提交的task被先执行完)</li></ul></li><li>thread: 采用C++11 标准库中的std::thread<ul><li>根据std::thread::hardware_concurrency()获取cpu数量进行任务cpu友好性优化, 目前此项目不支持</li><li>设置thread的cpu亲和性优化程序执行（Windows平台:通过SetThreadAffinityMask指定线程在cpu哪个核心上运行）</li></ul></li></ul><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h3><p><a href="https://github.com/zhangyebai/cplusplus-elf/tree/master/thread-pool" target="_blank" rel="noopener">Code On GitHub</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 几个需要注意的点:</span></span><br><span class="line"><span class="comment"> * 1、tasks的读写锁需要优化成带优先级的锁, 可以肯定线程池的绝大部分使用场景commit task比run task更密集</span></span><br><span class="line"><span class="comment"> * 2、根据tasks以及cpu扩展线程数</span></span><br><span class="line"><span class="comment"> * 3、支持允许缓存的task数,如果超出此数将采取拒绝策略</span></span><br><span class="line"><span class="comment"> * 4、拒绝策略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    ThreadPool(<span class="keyword">int</span> core, <span class="keyword">int</span> max = <span class="number">0</span>, <span class="keyword">int</span> cache = <span class="number">0</span>): core(core),<span class="comment">//由于max和cache暂时没用到,因此赋值0</span></span><br><span class="line">                    max(max), cache(cache), quit(<span class="literal">false</span>), force(<span class="literal">false</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    ~ThreadPool()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;quit.store(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;enable.notify_all();</span><br><span class="line">        <span class="built_in">std</span>::for_each(<span class="keyword">this</span>-&gt;pool.begin(), <span class="keyword">this</span>-&gt;pool.end(), [](<span class="built_in">std</span>::thread &amp; t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.joinable())&#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> idx = <span class="number">0</span>; idx &lt; core; ++idx)&#123;</span><br><span class="line">            pool.push_back(<span class="built_in">std</span>::thread([<span class="keyword">this</span>]()&#123;</span><br><span class="line">                <span class="comment">// 第一次退出,判断是否要强制退出</span></span><br><span class="line">                <span class="keyword">bool</span> quit = <span class="keyword">this</span>-&gt;force.load() ? <span class="keyword">this</span>-&gt;quit.load() : <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(; !quit;)&#123;</span><br><span class="line">                    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">this</span>-&gt;oper_lock);</span><br><span class="line">                    <span class="keyword">this</span>-&gt;enable.wait(lock, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;quit.load() || !<span class="keyword">this</span>-&gt;tasks.empty();</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">// 不是强制退出时可从这里退出</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;quit.load() &amp;&amp; <span class="keyword">this</span>-&gt;tasks.empty())&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task = <span class="built_in">std</span>::move(<span class="keyword">this</span>-&gt;tasks.front());</span><br><span class="line">                    <span class="keyword">this</span>-&gt;tasks.pop();</span><br><span class="line"></span><br><span class="line">                    task();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">bool</span> force = <span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;quit.store(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;force.store(force);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//void commit(std::function&lt;void (void * param)&gt; task);</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">auto</span> <span class="title">commit</span>(<span class="title">T</span> &amp;&amp; <span class="title">t</span>, <span class="title">Args</span>&amp;&amp;...<span class="title">args</span>)-&gt;<span class="title">std</span>:</span>:future&lt;<span class="keyword">decltype</span>(t(args...))&gt;&#123;</span><br><span class="line">        <span class="keyword">using</span> TYPE = <span class="keyword">decltype</span>(t(args...));</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;quit.load())&#123;</span><br><span class="line">            <span class="comment">//dont know return what, so throw an exception</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"thread pool is alreay shutdown."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1、std::packaged_task&lt;decltype(f(args...))() 类似std::function\</span></span><br><span class="line">            但是会将其封装的可调用元素的结果封装在<span class="built_in">std</span>::future中</span><br><span class="line">        <span class="comment">// 2、std::make_shared 创建std::packaged_task&lt;decltype(f(args...))()\</span></span><br><span class="line">            类型的智能指针</span><br><span class="line">        <span class="comment">// 3、std::bind(std::forward&lt;T&gt;(t), std::forward&lt;Args&gt;(args)...)当做\</span></span><br><span class="line">            <span class="built_in">std</span>::packaged_task的构造参数</span><br><span class="line">        <span class="keyword">auto</span> task = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::packaged_task&lt;TYPE()&gt; &gt;( </span><br><span class="line">            <span class="built_in">std</span>::bind(<span class="built_in">std</span>::forward&lt;T&gt;(t), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">std</span>::future&lt;TYPE&gt; result = task-&gt;get_future();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">this</span>-&gt;oper_lock);</span><br><span class="line">        <span class="comment">//将packaged_task 包裹在一个签名为void()的lambda函数中调用,因为此lambda函数符合std::function&lt;void()&gt;\</span></span><br><span class="line">            的签名,所以可以放到<span class="built_in">queue</span>中</span><br><span class="line">        <span class="keyword">this</span>-&gt;tasks.emplace([task]()&#123;</span><br><span class="line">            (*task)();  <span class="comment">//调用packaged_task</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>-&gt;enable.notify_one();  <span class="comment">// 在线程池中唤醒一个休眠的线程</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//void move();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; pool;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; &gt; tasks;</span><br><span class="line">    <span class="keyword">int</span> core;   <span class="comment">//线程池核心线程数</span></span><br><span class="line">    <span class="keyword">int</span> max;    <span class="comment">//线程池根据tasks量以及cpu数最大可扩展的量</span></span><br><span class="line">    <span class="keyword">int</span> cache;  <span class="comment">//运行tasks可缓存的最大task数,超出次数后commit将采取拒绝策略</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; quit;     <span class="comment">//线程池shutdown条件, true时shutdown</span></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; force;    <span class="comment">//是否强制shutdown,true时有剩余的task将不执行直接退出, false时等待执行完所有的task再退出</span></span><br><span class="line">    <span class="built_in">std</span>::condition_variable enable;     <span class="comment">//</span></span><br><span class="line">    <span class="built_in">std</span>::mutex oper_lock;   <span class="comment">// queue的读写锁</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>###Test Code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./pool/ThreadPool.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    pool.start();</span><br><span class="line">    <span class="built_in">std</span>::default_random_engine rd;</span><br><span class="line">    <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; rang(<span class="number">100</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="number">20</span>; ++idx)&#123;</span><br><span class="line">        pool.commit([=](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread id : "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() </span><br><span class="line">                &lt;&lt; <span class="string">" x = "</span> &lt;&lt; x &lt;&lt; <span class="string">" y = "</span> &lt;&lt; y &lt;&lt;</span><br><span class="line">                <span class="string">" sleep time = "</span> &lt;&lt; t &lt;&lt; <span class="string">" ms"</span> &lt;&lt;</span><br><span class="line">                <span class="string">" id = "</span> &lt;&lt; idx &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(t));</span><br><span class="line">        &#125;, rang(rd), rang(rd), rang(rd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; &gt; results;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index = <span class="number">20</span>; index &lt; <span class="number">50</span>; ++index)&#123;</span><br><span class="line">        results.push_back(</span><br><span class="line">            pool.commit([=]()-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp; r : results)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"get result from thread "</span></span><br><span class="line">        &lt;&lt; <span class="string">" index = "</span> &lt;&lt; r.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> command = <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="string">'q'</span>)&#123;</span><br><span class="line">        pool.shutdown(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">'e'</span>)&#123;</span><br><span class="line">        pool.shutdown(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            pool.commit([]()&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i want to get an exception"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test finish, OY!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compile-link"><a class="markdownIt-Anchor" href="#compile-link"></a> Compile &amp; Link</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -O3 -Wall -std=c++11 main.cpp -o ./out/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="run"><a class="markdownIt-Anchor" href="#run"></a> Run</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">thread id : 0x70000a352000 x = 242 y = 937 sleep time = 480 ms id = 0</span><br><span class="line">thread id : 0x70000a352000 x = 340 y = 390 sleep time = 692 ms id = 1</span><br><span class="line">thread id : 0x70000a352000 x = 188 y = 294 sleep time = 738 ms id = 2</span><br><span class="line">thread id : 0x70000a352000 x = 390 y = 978 sleep time = 270 ms id = 3</span><br><span class="line">thread id : 0x70000a4db000 x = 432 y = 780 sleep time = 102 ms id = 4</span><br><span class="line">thread id : 0x70000a458000 x = 652 y = 661 sleep time = 498 ms id = 5</span><br><span class="line">thread id : 0x70000a3d5000 x = 839 y = 452 sleep time = 487 ms id = 6</span><br><span class="line">thread id : 0x70000a352000 x = 698 y = 540 sleep time = 183 ms id = 7</span><br><span class="line">thread id : 0x70000a4db000 x = 157 y = 983 sleep time = 638 ms id = 8</span><br><span class="line">thread id : 0x70000a3d5000 x = 232 y = 823 sleep time = 766 ms id = 9</span><br><span class="line">thread id : 0x70000a458000 x = 801 y = 411 sleep time = 314 ms id = 10</span><br><span class="line">thread id : 0x70000a458000 x = 359 y = 912 sleep time = 294 ms id = 11</span><br><span class="line">thread id : 0x70000a458000 x = 260 y = 142 sleep time = 372 ms id = 12</span><br><span class="line">thread id : 0x70000a458000 x = 618 y = 499 sleep time = 831 ms id = 13</span><br><span class="line">thread id : 0x70000a458000 x = 108 y = 319 sleep time = 376 ms id = 14</span><br><span class="line">thread id : 0x70000a3d5000 x = 870 y = 490 sleep time = 519 ms id = 15</span><br><span class="line">thread id : 0x70000a352000 x = 446 y = 998 sleep time = 496 ms id = 16</span><br><span class="line">thread id : 0x70000a3d5000 x = 321 y = 308 sleep time = 610 ms id = 17</span><br><span class="line">thread id : 0x70000a3d5000 x = 247 y = 256 sleep time = 629 ms id = 18</span><br><span class="line">thread id : 0x70000a3d5000 x = 186 y = 484 sleep time = 703 ms id = 19</span><br><span class="line">get result from thread  index = 20</span><br><span class="line">get result from thread  index = 21</span><br><span class="line">get result from thread  index = 22</span><br><span class="line">get result from thread  index = 23</span><br><span class="line">get result from thread  index = 24</span><br><span class="line">get result from thread  index = 25</span><br><span class="line">get result from thread  index = 26</span><br><span class="line">get result from thread  index = 27</span><br><span class="line">get result from thread  index = 28</span><br><span class="line">get result from thread  index = 29</span><br><span class="line">get result from thread  index = 30</span><br><span class="line">get result from thread  index = 31</span><br><span class="line">get result from thread  index = 32</span><br><span class="line">get result from thread  index = 33</span><br><span class="line">get result from thread  index = 34</span><br><span class="line">get result from thread  index = 35</span><br><span class="line">get result from thread  index = 36</span><br><span class="line">get result from thread  index = 37</span><br><span class="line">get result from thread  index = 38</span><br><span class="line">get result from thread  index = 39</span><br><span class="line">get result from thread  index = 40</span><br><span class="line">get result from thread  index = 41</span><br><span class="line">get result from thread  index = 42</span><br><span class="line">get result from thread  index = 43</span><br><span class="line">get result from thread  index = 44</span><br><span class="line">get result from thread  index = 45</span><br><span class="line">get result from thread  index = 46</span><br><span class="line">get result from thread  index = 47</span><br><span class="line">get result from thread  index = 48</span><br><span class="line">get result from thread  index = 49</span><br><span class="line">e</span><br><span class="line">thread pool is alreay shutdown.</span><br><span class="line">test finish, OY!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;c线程池&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c线程池&quot;&gt;&lt;/a&gt; C++线程池&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;进程的创建和销毁,代价是昂贵的,除去操作系统的实现及其本身的原理,跟线程相比它更显得重量级。&lt;br&gt;
这几年互联网的迅速发展,让线程正面临着跟进程一样的“重量级”困扰。尤其是GO等语言退出协程(纤程)&lt;br&gt;
后,线程更是不堪其重。那么有没有改进的方向呢？有,将线程池化——线程池。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于C++版本推进的历程(&lt;code&gt;C++98&lt;/code&gt;, &lt;code&gt;C++03&lt;/code&gt;, &lt;code&gt;C++11&lt;/code&gt;, &lt;code&gt;C++14&lt;/code&gt;, &lt;code&gt;C++17&lt;/code&gt;, &lt;code&gt;C++20&lt;/code&gt;)以及其&lt;br&gt;
弱鸡般的ABI兼容性,导致很多框架用起来得自己造轮子。C++版本再吐槽一句好了, C++即使版本推进到&lt;br&gt;
0xff, 对很多人来说还是c with class, 包括我。&lt;br&gt;
我们的目标是, 造一个很Java中的ThreadPool类似的线程池。目前的进度:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[x] 极其简易的线程池(header only)&lt;/li&gt;
&lt;li&gt;[x] 支持设置线程池核心线程数&lt;/li&gt;
&lt;li&gt;[ ] 支持设置线程池最大线程数&lt;/li&gt;
&lt;li&gt;[ ] 支持设置最大缓存的任务数&lt;/li&gt;
&lt;li&gt;[ ] 支持设置任务提交拒绝策略&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="FrameWork" scheme="http://www.zhangyebai.com/categories/FrameWork/"/>
    
    
      <category term="C++" scheme="http://www.zhangyebai.com/tags/C/"/>
    
      <category term="线程" scheme="http://www.zhangyebai.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://www.zhangyebai.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 053 - Maximum-Sub-Array</title>
    <link href="http://www.zhangyebai.com/2019/02/12/maximum-sub-array/"/>
    <id>http://www.zhangyebai.com/2019/02/12/maximum-sub-array/</id>
    <published>2019-02-12T13:37:45.000Z</published>
    <updated>2019-02-12T14:45:46.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">官方地址</a></p><ul><li><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></li><li><p>示例:</p></li><li><p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p></li><li><p>输出: 6</p></li><li><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></li><li><p>进阶:</p></li><li><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><pre><code> 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法…… 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。</code></pre></li></ul><a id="more"></a><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> Java Solution</h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><ul><li>✔ Accepted</li><li>✔ 202/202 cases passed (16 ms)</li><li>✔ Your runtime beats 31.02 % of java submissions</li><li>✔ 2019-02-12 21:31:45</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];  <span class="comment">//sum保存着跟随idx遍历nums每个索引为结束位置的最大值（不是太好理解）</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];  <span class="comment">//max保存着idx及其以前的元素为结束位置的最大值</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt; nums.length; ++idx)&#123;   <span class="comment">//注意idx从1开始,因为sum和max不能初始化为0,</span></span><br><span class="line">                                                    <span class="comment">//只能初始化为nums[0],因为nums中的元素可能是负数</span></span><br><span class="line">            sum = Math.max(sum + nums[idx], nums[idx]); <span class="comment">//注意sum是以idx索引元素为结束位置的最大值（包含idx）</span></span><br><span class="line">            max = Math.max(sum, max);   <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    (max: 全局的最大值,也就是我们要求的结果; sum: 局部最大值,代表的是以某元素结尾的最大值)    -1 2 -3 4 -1    idx = 0: sum = -1, max = -1 (注: 此步骤即是初始化sum和max, 也就是第一个元素为结尾的局部最大值和全局最大值)    idx = 1: sum = (-1 + 2), max = sum = 1    idx = 2: sum = (1 + -3), max = 1    idx = 3: sum = 4, max = sum = 4    idx = 4: sum = (4 + -1), max = 4    所以求得结果max=4    注意到此题有dp解法,后续增加</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;description&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#description&quot;&gt;&lt;/a&gt; Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方地址&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出: 6&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进阶:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法……
 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 002 - Add Two Numbers (Medium)</title>
    <link href="http://www.zhangyebai.com/2017/02/19/add-two-numbers/"/>
    <id>http://www.zhangyebai.com/2017/02/19/add-two-numbers/</id>
    <published>2017-02-19T07:08:44.000Z</published>
    <updated>2019-02-12T14:51:34.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="descripiton"><a class="markdownIt-Anchor" href="#descripiton"></a> Descripiton</h2><pre><code>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in  reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。  这句话什么意思呢？换句话说就是这样：  比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4);19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1);因为表示顺序是反着的，所以进位也是反着的。假设这两个数字不包含任何的头结点0，除了数字0本身。</code></pre><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8</code></pre><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><pre><code>通过描述中的大致分析可以看出，需要遍历两个Linked-List中的对应的Node并取数相加，然后生成新Node并添加到result的Link-List中。- 2个Linked-List中对应的Node，如果有一个为null，一个不为null，则结果节点直接使用不为null的Node中的值去构造即可;- 如果两个Node相加需要进位，切记是向后进位，如果有后续Node，计算是需要加上进位;- 如果两个Node相加需要进位，且没有后续Node，则需要添加一个Node，值用进位的数即可;- 以下代码截止到提交日期，均已被LeetCode AC；</code></pre><h2 id="python-solution"><a class="markdownIt-Anchor" href="#python-solution"></a> <code>Python Solution</code></h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Node定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LeetCode的命名规范我已经无力吐槽了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            :type l1: ListNode</span></span><br><span class="line"><span class="string">            :type l2: ListNode</span></span><br><span class="line"><span class="string">            :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = ListNode(<span class="number">0</span>)</span><br><span class="line">        step = result</span><br><span class="line">        l_hand, r_hand = l1, l2</span><br><span class="line">        node_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">or</span> r_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            node_sum //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> l_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                node_sum += l_hand.val</span><br><span class="line">                l_hand = l_hand.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                node_sum += r_hand.val</span><br><span class="line">                r_hand = r_hand.next</span><br><span class="line"></span><br><span class="line">            step.next = ListNode(node_sum % <span class="number">10</span>)</span><br><span class="line">            step = step.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node_sum // <span class="number">10</span> &gt; <span class="number">0</span>:</span><br><span class="line">            step.next = ListNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.next</span><br><span class="line"><span class="comment">#TestCase</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_node</span><span class="params">(param)</span>-&gt;ListNode:</span></span><br><span class="line">    result_node, temp_node = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> param:</span><br><span class="line">        <span class="keyword">if</span> result_node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            temp_node = ListNode(value)</span><br><span class="line">            result_node = temp_node</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        temp_node.next = ListNode(value)</span><br><span class="line">        temp_node = temp_node.next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_node</span><span class="params">(param_node: ListNode)</span>-&gt;<span class="keyword">None</span>:</span></span><br><span class="line">    temp_node, values = param_node, []</span><br><span class="line">    <span class="keyword">while</span> temp_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        values.append(str(temp_node.val))</span><br><span class="line">        temp_node = temp_node.next</span><br><span class="line">    print(<span class="string">'['</span>, <span class="string">'-&gt;'</span>.join(values), <span class="string">']'</span>, sep=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l_node = init_node([<span class="number">3</span>, <span class="number">7</span>])</span><br><span class="line">    r_node = init_node([<span class="number">9</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    print_node(Solution().add_two_nums(l_node, r_node))</span><br></pre></td></tr></table></figure><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> <code>Java Solution</code></h2><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode step = result;</span><br><span class="line">        ListNode l_hand = l1;</span><br><span class="line">        ListNode r_hand = l2;</span><br><span class="line">        <span class="keyword">int</span> node_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;l_hand != <span class="keyword">null</span> || r_hand != <span class="keyword">null</span>;)&#123;</span><br><span class="line">            node_sum /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (l_hand != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node_sum += l_hand.val;</span><br><span class="line">                l_hand = l_hand.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r_hand !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                node_sum += r_hand.val;</span><br><span class="line">                r_hand = r_hand.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            step.next = <span class="keyword">new</span> ListNode(node_sum % <span class="number">10</span>);</span><br><span class="line">            step = step.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node_sum / <span class="number">10</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            step.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TestCase</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(node.val);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不要问我这两个数组时哪里来的，没有错误的程序是不会知道的</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = &#123;<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        printNode(<span class="keyword">new</span> AddTwoNumbers().addTwoNumbers(initList(arr1), initList(arr2)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-solution"><a class="markdownIt-Anchor" href="#c-solution"></a> <code>C++ Solution</code></h2><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTwoNumbers</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">ListNode *step = &amp;head, *l_hand = l1, *r_hand = l2;</span><br><span class="line"><span class="keyword">int</span> node_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; l_hand || r_hand;) </span><br><span class="line">&#123;</span><br><span class="line">node_sum /= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (l_hand) </span><br><span class="line">&#123;</span><br><span class="line">node_sum += l_hand-&gt;val;</span><br><span class="line">l_hand = l_hand-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r_hand) </span><br><span class="line">&#123;</span><br><span class="line">node_sum += r_hand-&gt;val;</span><br><span class="line">r_hand = r_hand-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">step-&gt;next = <span class="keyword">new</span> ListNode(node_sum % <span class="number">10</span>);</span><br><span class="line">step = step-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node_sum / <span class="number">10</span> &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">step-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;descripiton&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#descripiton&quot;&gt;&lt;/a&gt; Descripiton&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in  
reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。  
这句话什么意思呢？换句话说就是这样：  
	比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&amp;gt;Node(1) + Node(1)-&amp;gt;Node(2) = Node(0)-&amp;gt;Node(4);
	19 + 91 = 110就表示为Node(9)-&amp;gt;Node(1) + Node(1)-&amp;gt;Node(9) = Node(0)-&amp;gt;Node(1)-&amp;gt;Node(1);
	因为表示顺序是反着的，所以进位也是反着的。
假设这两个数字不包含任何的头结点0，除了数字0本身。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;example&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#example&quot;&gt;&lt;/a&gt; Example&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
Output: 7 -&amp;gt; 0 -&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="Python" scheme="http://www.zhangyebai.com/tags/Python/"/>
    
      <category term="C++" scheme="http://www.zhangyebai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Singleton - 单例模式 - Java</title>
    <link href="http://www.zhangyebai.com/2017/02/13/Singleton/"/>
    <id>http://www.zhangyebai.com/2017/02/13/Singleton/</id>
    <published>2017-02-13T15:48:30.000Z</published>
    <updated>2019-02-12T14:42:52.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2><ul><li><p>One instance of a class or one value accessible globally in an application.</p><ul><li>Ensure that only one instance of a class is created.</li><li>Provide a global point of access to the object.</li></ul></li><li><p>在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点:</p><ul><li>确保该唯一实例被创建。</li><li>为外界使用该实例提供一个全局的访问入口。</li><li>对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。</li></ul></li></ul><a id="more"></a><h2 id="简单懒汉式单例模式"><a class="markdownIt-Anchor" href="#简单懒汉式单例模式"></a> 简单懒汉式单例模式</h2><pre><code>- 简单 * 3，但是致命缺点是线程不安全。- 懒汉式:在Singleton被ClassLoader加载时并不实例化instance，只有在需要时(即调用getInstance方法时)才会触发实例化。- getInstance，newInstance在命名规范上的区别是分别对应单例和多例!</code></pre><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次 3ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRuntime</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> timestart = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, loop = <span class="number">10000000</span>; index &lt; loop; ++index)&#123;</span><br><span class="line">Singleton singletonThread1 = Singleton.getSingletonInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> timeend = System.currentTimeMillis();</span><br><span class="line">System.out.println(timeend - timestart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;Singleton, Integer&gt; hMap = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Singleton singleton = Singleton.getSingletonInstance();</span><br><span class="line">hMap.put(singleton, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*开启了100000个线程测试，并未发现有多个实例的现象，但是此种做法确实是存在多例的风险，原因在于当两个线程同时调用  </span></span><br><span class="line"><span class="comment">getSingletonInstance()且instance都为null时，两个线程可能会同时执行instance = new Singleton();*/</span></span><br></pre></td></tr></table></figure><h2 id="线程安全懒汉式单例模式"><a class="markdownIt-Anchor" href="#线程安全懒汉式单例模式"></a> 线程安全懒汉式单例模式</h2><pre><code>- 通过对全局入口方法加同步来解决线程安全的问题。- 带来的后果是资源的开销是非常大的，因为初始化完instance后不再需要synchronized- 毕竟线程安全了。</code></pre><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> synchroized Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次调用 56ms （简单懒汉式单例模式中为3ms）</span></span><br><span class="line"><span class="comment">//测试代码参考 简单懒汉式单例模式 中代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="comment">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span></span><br></pre></td></tr></table></figure><h2 id="改进效率版懒汉式单例模式"><a class="markdownIt-Anchor" href="#改进效率版懒汉式单例模式"></a> 改进效率版懒汉式单例模式</h2><pre><code>- synchroized 同步方法的资源开销是很大的。- 改进点在于用synchronized同步实例化代码块，这样的好处是一旦实例化完成，以后的调用不会再触碰到synchronized。</code></pre><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton  implements java.io.Serializable&#123;</span><br><span class="line">private volatile static Singleton instance;</span><br><span class="line">private Singleton()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static  Singleton getSingletonInstance()&#123;</span><br><span class="line">if (instance == null)&#123;</span><br><span class="line">synchroized(Singleton.class)&#123;</span><br><span class="line">if(instance == null)&#123;</span><br><span class="line">instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Object readResolve()&#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//RuntimeTestCase 10000000次调用 3ms 理论上来说应该于 简单懒汉式单例模式 中的实现效率持平。</span><br><span class="line">//测试代码参考 简单懒汉式单例模式 中代码</span><br><span class="line"></span><br><span class="line">//MultipleInstanceTestCase</span><br><span class="line">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span><br></pre></td></tr></table></figure><h2 id="饿汉式单例模式"><a class="markdownIt-Anchor" href="#饿汉式单例模式"></a> 饿汉式单例模式</h2><pre><code>- 触发ClassLoader加载该类时实例化。- 与懒汉式的区别是:主动实例化。</code></pre><h3 id="code-4"><a class="markdownIt-Anchor" href="#code-4"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种写法是通过静态代码块实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次调用 2ms。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="comment">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span></span><br></pre></td></tr></table></figure><h2 id="静态内部类实现单例"><a class="markdownIt-Anchor" href="#静态内部类实现单例"></a> 静态内部类实现单例</h2><pre><code>- 实现延迟实例化。- 线程安全。- 推荐使用。</code></pre><h3 id="code-5"><a class="markdownIt-Anchor" href="#code-5"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonController</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonController.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonController.instance;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次调用 3ms 。</span></span><br><span class="line"><span class="comment">//测试代码参考 简单懒汉式单例模式 中代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="comment">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span></span><br></pre></td></tr></table></figure><h2 id="枚举实现"><a class="markdownIt-Anchor" href="#枚举实现"></a> 枚举实现</h2><p>最近在看《Effective java 中文版2th》的时候，看到的此种方法，顿时被惊呆。以下为书中原话:</p><pre><code>- since jdk 1.5 。- 只需编写一个包含单个元素的枚举类型即可实现。- 此方法在功能上与公有域方法接近，但是它更加简洁，无偿地提供了序列化机制。- 绝对的防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。- 虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</code></pre><h3 id="code-6"><a class="markdownIt-Anchor" href="#code-6"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="comment">//代码至此已经完事。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单例模式&quot;&gt;&lt;/a&gt; 单例模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;One instance of a class or one value accessible globally in an application.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ensure that only one instance of a class is created.&lt;/li&gt;
&lt;li&gt;Provide a global point of access to the object.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保该唯一实例被创建。&lt;/li&gt;
&lt;li&gt;为外界使用该实例提供一个全局的访问入口。&lt;/li&gt;
&lt;li&gt;对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://www.zhangyebai.com/categories/Design-Pattern/"/>
    
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://www.zhangyebai.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://www.zhangyebai.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 001 - Two Sum (Easy)</title>
    <link href="http://www.zhangyebai.com/2017/02/13/two-sum/"/>
    <id>http://www.zhangyebai.com/2017/02/13/two-sum/</id>
    <published>2017-02-12T21:02:51.000Z</published>
    <updated>2019-02-12T14:51:39.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="descripiton"><a class="markdownIt-Anchor" href="#descripiton"></a> Descripiton</h2><pre><code>Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。</code></pre><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><ul><li>利用map数据结构的Key-Value键值对的存储特点，遍历array数组时，查看当前数组元素value与目标target的差（<strong>target - value</strong>）是否在map的keys中，如果存在说明前面的遍历时找到了第一个value，取出索引并返回当前索引即可;如果没找到，将当前value作为key，当前索引index作为key的value放置进map继续遍历即可。<ul><li>Python中map数据结构为字典（dict）</li><li>适当关注一下c++中std::map和std::vector的相关操作</li><li>以下代码截止到提交日期，均已被LeetCode AC</li></ul></li></ul><h2 id="python-solution"><a class="markdownIt-Anchor" href="#python-solution"></a> <code>Python Solution</code></h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_num</span><span class="params">(nums, target)</span>-&gt;object:</span></span><br><span class="line">nums_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> loop, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line"><span class="keyword">if</span> nums_dict.__contains__(target - value):</span><br><span class="line"><span class="keyword">return</span> [nums_dict[target - value], loop]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums_dict[value] = loop</span><br><span class="line"></span><br><span class="line"><span class="comment">#TestCase</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num_list = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">    target_num = <span class="number">22</span></span><br><span class="line">    result = Solution().two_num(num_list, target_num)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> result:</span><br><span class="line">            print(<span class="string">'-&gt;'</span>.join([str(index), str(num_list[index])]))</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        print(<span class="string">'no target to find'</span>)</span><br></pre></td></tr></table></figure><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> <code>Java Solution</code></h2><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">Map&amp;ltInteger, Integer&gt; map = <span class="keyword">new</span> HashMap&amp;ltInteger, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>, length = nums.length; index &lt; length; ++index)&#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target - nums[index]))&#123;</span><br><span class="line">    result[<span class="number">0</span>] = map.get(target - nums[index]);</span><br><span class="line">        result[<span class="number">1</span>] = index;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.put(nums[index], index);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-solution"><a class="markdownIt-Anchor" href="#c-solution"></a> <code>C++ Solution</code></h2><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; loop;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> index = <span class="number">0</span>; index &lt; nums.size(); ++index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (loop.find(target - nums.at(index)) != loop.cend())</span><br><span class="line">&#123;</span><br><span class="line">result.push_back(loop.at(target - nums.at(index)));</span><br><span class="line">result.push_back(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">loop.insert(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(nums.at(index), index));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TestCase</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Solution solution;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = solution.twoSum(nums, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = result.begin(); iter != result.end(); ++iter)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> timing = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; timing;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;descripiton&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#descripiton&quot;&gt;&lt;/a&gt; Descripiton&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.

给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。
假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;example&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#example&quot;&gt;&lt;/a&gt; Example&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="Python" scheme="http://www.zhangyebai.com/tags/Python/"/>
    
      <category term="C++" scheme="http://www.zhangyebai.com/tags/C/"/>
    
  </entry>
  
</feed>
