<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一码平川</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhangyebai.com/"/>
  <updated>2019-02-22T18:03:19.976Z</updated>
  <id>http://www.zhangyebai.com/</id>
  
  <author>
    <name>张夜白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>code-hand-writing</title>
    <link href="http://www.zhangyebai.com/2019/02/23/code-hand-writing/"/>
    <id>http://www.zhangyebai.com/2019/02/23/code-hand-writing/</id>
    <published>2019-02-22T16:42:52.000Z</published>
    <updated>2019-02-22T18:03:19.976Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在的IDE越来越智能, 没错我说的就是IDEA及其各种插件, 它几乎几乎能无缝贴合你编程时候的思想。有时候你甚至只需要敲一个字母, 它就能帮你联想一整句代码语句。各种错误检测手段、智能提示、优化提示是不是正在侵蚀程序员的思维呢？</p></blockquote><p>最近我在压力下手书了两段代码, 惨不忍睹。真的会发慌, 不只是对陌生环境不适应(比如没有自己常用的开发环境), 更多的是感觉没有了IDE自己手写的每一行代码都是错的。</p><a id="more"></a><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><p>手书代码(一字未改):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    这是个错误的实现。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == arr)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == arr.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - j; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> ( j = arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有什么问题?</p><ol><li>可以使用更优化的遍历方式</li><li>可以使用更清晰的index起始方式让代码更易读</li><li>错误的判断了冒泡本身的循环和进行冒泡次数的循环之间的关系, 从而导致了越界判断, 这是错误的, 这里面并没有越界问题</li><li>我甚至函数名只写了sort, 当时脑海中并没有浮现bubble这个单词</li><li>我几乎在提交的那一刹就想起了这些问题</li></ol><p>优化的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == arr)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == arr.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归的问题"><a class="markdownIt-Anchor" href="#递归的问题"></a> 递归的问题</h3><p>斐波那契数列第N项</p><p>手书代码(一字未改):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> calc(n - <span class="number">1</span>) + calc(n -<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段手书代码有什么问题:</p><ol><li>少了参数n的范围判断, 负值的情况</li><li>手书过程中没有想起尾递归优化</li><li>手书过程中没有想起循环优化递归</li><li>提交的一刹那我想起来了这些问题</li><li>我甚至连fibonacci都想不起来怎么拼, 所以只能写个calc</li></ol><p>正常的递归代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    二叉树状展开栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"fibonacci index cant be negative"</span>);</span><br><span class="line">    <span class="keyword">if</span>( index == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( index == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> fibo(n - <span class="number">1</span>) + fibo(n -<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾递归优化代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wrapper</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( index &lt;= <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"fibonacci index cant be negative"</span>);</span><br><span class="line">    <span class="keyword">return</span> fiboTail(index, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    index: fibonacci 第N项</span></span><br><span class="line"><span class="comment">    pre: 代表index的前两项</span></span><br><span class="line"><span class="comment">    cur: 代表index 的前一项</span></span><br><span class="line"><span class="comment">    可以看到是带着计算结果向下递归(也就是反向递归 == 尾递归), 线性展开栈</span></span><br><span class="line"><span class="comment">    其实它跟用循环代替递归有点像, 极大的减小了栈展开复杂度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fiboTail</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> pre, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( index == <span class="number">1</span>) <span class="keyword">return</span> pre;</span><br><span class="line">    <span class="keyword">if</span>( index == <span class="number">2</span>) <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fiboTail(index - <span class="number">1</span>, cur, pre + cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环版的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    无栈展开</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fiboLoop</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( index &lt;= <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"fibonacci index cant be negative"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt;= index; ++ idx)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( idx == <span class="number">1</span>)&#123;</span><br><span class="line">            cur = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>( idx == <span class="number">2</span>)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = cur;</span><br><span class="line">        cur = cur + pre;</span><br><span class="line">        pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结语:<br>我相信肯定不止我一个人面临这种问题, 这到底是技术让人退化了, 还是人利用技术升级了呢……你开始怀疑这到底是你脑子的问题, 还是键盘和手的问题。<br>to be continue</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;现在的IDE越来越智能, 没错我说的就是IDEA及其各种插件, 它几乎几乎能无缝贴合你编程时候的思想。有时候你甚至只需要敲一个字母, 它就能帮你联想一整句代码语句。各种错误检测手段、智能提示、优化提示是不是正在侵蚀程序员的思维呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近我在压力下手书了两段代码, 惨不忍睹。真的会发慌, 不只是对陌生环境不适应(比如没有自己常用的开发环境), 更多的是感觉没有了IDE自己手写的每一行代码都是错的。&lt;/p&gt;
    
    </summary>
    
      <category term="编程小杂感" scheme="http://www.zhangyebai.com/categories/%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%9D%82%E6%84%9F/"/>
    
    
      <category term="handwriting" scheme="http://www.zhangyebai.com/tags/handwriting/"/>
    
      <category term="编程感想" scheme="http://www.zhangyebai.com/tags/%E7%BC%96%E7%A8%8B%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>redis里的小秘密[0x00]</title>
    <link href="http://www.zhangyebai.com/2019/02/17/secret-in-redis-0x00/"/>
    <id>http://www.zhangyebai.com/2019/02/17/secret-in-redis-0x00/</id>
    <published>2019-02-17T09:51:43.000Z</published>
    <updated>2019-02-18T05:31:24.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="linux-macos下设置进程名"><a class="markdownIt-Anchor" href="#linux-macos下设置进程名"></a> linux macOS下设置进程名</h3><blockquote><p>base on redis source code 5.0.3</p></blockquote><p>在redis server启动过程中, 有一个宏和一个函数显得很奇特, 他们是<code>server.c</code>中<code>main()</code>函数<br>中的第一个宏和第一个函数, 宏<code>INIT_SETPROCTITLE_REPLACEMENT</code>和函数<code>spt_init(argc, argv);</code>.<br>他俩组合在一起的主要功能是在macOS和*nix下设置(修改)redis的各个进程名, 例如<code>redis-aof-rewrite</code>、<br><code>redis-rdb-bgsave</code>等。<br>那么他们是如何工作的呢?想知道这些, 这得从main函数说起。请看标准的main函数签名:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>macOS和*nix系统创建进程后会给进程分配一个全局的environment环境变量<code>char ** environ</code>, 它是一个<code>char*</code>数组, 里面保存的是类似<code>{k=v, k=v, k=v}</code>这样的字符串数组。如果我们想使用它可以像下面这样(实际上redis也是这样做的):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> ** environ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> idx = <span class="number">0</span>; idx &lt; argc; ++idx)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(argv[idx]) &lt;&lt; <span class="string">" = "</span> &lt;&lt; argv[idx] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> idx = <span class="number">0</span>; <span class="literal">nullptr</span> != environ[idx]; ++idx)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(environ[idx]) &lt;&lt; <span class="string">" = "</span> &lt;&lt; environ[idx] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -Wall -std=c++11 main.cpp -o <span class="built_in">test</span></span><br><span class="line">./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>在我的mac下运行结果如下(其实就是系统给进程设置的环境变量):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0x7ffeed1afa80 = ./test     // argv[0]</span><br><span class="line">0x7ffeed1afa87 = __CF_USER_TEXT_ENCODING=0x1F5:0x0:0x0  //environ[0]</span><br><span class="line">0x7ffeed1afaad = TMPDIR=/var/folders/5y/c9fbgn3x6p90sl9gbx_y1qnm0000gn/T/</span><br><span class="line">0x7ffeed1afae6 = HOME=/Users/zhangyebai</span><br><span class="line">0x7ffeed1afafd = SHELL=/bin/zsh</span><br><span class="line">0x7ffeed1afb0c = Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.Ey7nIaeRPX/Render</span><br><span class="line">0x7ffeed1afb58 = SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.CT1oMhwGyS/Listeners</span><br><span class="line">0x7ffeed1afb9a = PATH=/usr/local/opt/icu4c/sbin:/usr/local/opt/icu4c/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/opt/icu4c/sbin:/usr/local/opt/icu4c/bin:/usr/local/sbin:/Users/zhangyebai/scripts:/usr/local/mysql/bin:/Users/zhangyebai/scripts:/usr/local/mysql/bin</span><br><span class="line">0x7ffeed1afcb0 = LOGNAME=zhangyebai</span><br><span class="line">0x7ffeed1afcc3 = XPC_SERVICE_NAME=0</span><br><span class="line">0x7ffeed1afcd6 = COMMAND_MODE=unix2003</span><br><span class="line">0x7ffeed1afcec = USER=zhangyebai</span><br><span class="line">0x7fe8f2502450 = XPC_FLAGS=0x0</span><br><span class="line">0x7ffeed1afd0a = TERM_PROGRAM=vscode</span><br><span class="line">0x7ffeed1afd1e = TERM=xterm-256color</span><br><span class="line">0x7ffeed1afd32 = TERM_PROGRAM_VERSION=1.31.1</span><br><span class="line">0x7ffeed1afd4e = TERM_SESSION_ID=3B84E1B2-C0C2-426C-8AE3-00C01A9F6D5B</span><br><span class="line">0x7ffeed1afd83 = ZSH=/Users/zhangyebai/.oh-my-zsh</span><br><span class="line">0x7ffeed1afda4 = PAGER=less</span><br><span class="line">0x7ffeed1afdaf = LSCOLORS=Gxfxcxdxbxegedabagacad</span><br><span class="line">0x7ffeed1afdcf = PWD=/Users/zhangyebai/code/cpp/redis</span><br><span class="line">0x7ffeed1afdf4 = SHLVL=1</span><br><span class="line">0x7ffeed1afdfc = LESS=-R</span><br><span class="line">0x7ffeed1afe04 = LC_CTYPE=en_US.UTF-8</span><br><span class="line">0x7ffeed1afe19 = SECURITYSESSIONID=186a9</span><br><span class="line">0x7ffeed1afe31 = APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL=true</span><br><span class="line">0x7ffeed1afe61 = OLDPWD=/Users/zhangyebai/code/cpp/redis/testdwnakdihjwaijdiwaljdiowadwadwadwa.dSYM</span><br><span class="line">0x7ffeed1afeb4 = LANG=en_US.UTF-8</span><br><span class="line">0x7ffeed1afec5 = _=/Users/zhangyebai/code/cpp/redis/./test</span><br></pre></td></tr></table></figure><p><code>environ</code> 跟<code>int main(int argc, char ** argv)</code>有着什么样的关系呢? 如下所示:</p><pre><code>'argv[0][content]\0' 'argv[1][content]\0' ... 'argv[n][content]\0' nullptr 'environ[0][content]\0' 'environ[1][content]\0' ... 'envrion[x][content]\0'</code></pre><p>可以看到他们是一段连续的内存, 下面我们举个例子把它实例化看一下:</p><pre><code>argv[0] argv[1] nullptr environ[0] environ[1] a \0    b \0   nullptr   d=2\0       e=3\0 0  1    2  3             4567        891011base = 0x7ffeeaf21a80offset = 0, 1, 2 ... 11</code></pre><p>说完<code>argv</code>、<code>environ</code>的内存布局, 我们就可以开始看redis是如何设置进程名的了, 这里先直接给出答案: argv[0]里面对应的就是进程名。但是先别着急, 想要修改它可也没那么容易。因为什么? 上面我们说了, <code>argv</code>、<code>environ</code>可是内存连续的, 如果你设置了一个新的进程名长度比原来的长, 那么悲剧即将发生。它将覆盖argv[0]后面的缓冲区, 这将是致命的。<code>argv</code>、<code>environ</code>在进程运行过程中随时可能会用到,它们很重要。好了, 下面我们看redis怎么做的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c line 4035 version 5.0.3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">//....more</span></span><br><span class="line">    <span class="comment">/* We need to initialize our libraries, and the server configuration. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//...more</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>setproctitle.c</code>中<code>line 152</code>展开<code>spt_init(argc, argv);</code>, 我们一行一行来看(<strong>这里点名表扬redis的函数尾注释</strong>):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spt_init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> **envp = environ;</span><br><span class="line">    <span class="keyword">char</span> *base, *end, *nul, *tmp;</span><br><span class="line">    <span class="keyword">int</span> i, error;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注意这里的base, 被赋值argv[0],由于上面说了argv和environ</span></span><br><span class="line"><span class="comment">        是内存连续的, 在经历下面的操作以后argv 和 environ这边连续</span></span><br><span class="line"><span class="comment">        的内存将退化成char*类型的base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!(base = argv[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// nul表示argv[0], 也就是base字符串, </span></span><br><span class="line">    <span class="comment">// 也就是进程名字符串的结束位置(不包括\0)</span></span><br><span class="line">    nul = &amp;base[<span class="built_in">strlen</span>(base)];</span><br><span class="line">    end = nul + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        虽然argv和environ是连续的内存, 但是其中包含\0, 而且不知道</span></span><br><span class="line"><span class="comment">        environ的长度,所以得遍历二者, 将这片内存退化成char*, </span></span><br><span class="line"><span class="comment">        也就是base</span></span><br><span class="line"><span class="comment">        step 1: 遍历argv</span></span><br><span class="line"><span class="comment">        note: for循环的条件判断很奇怪, 我暂时没遇到满足这样奇怪条件</span></span><br><span class="line"><span class="comment">        的启动参数, 可能redis的开发人员在不同的操作系统上遇到这么怪异</span></span><br><span class="line"><span class="comment">        的问题, 有待探究。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc || (i &gt;= argc &amp;&amp; argv[i]); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!argv[i] || argv[i] &lt; end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        end = argv[i] + <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        step 2: 遍历 environ</span></span><br><span class="line"><span class="comment">        note: for循环中的这个if判断同样很奇怪</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; envp[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (envp[i] &lt; end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        end = envp[i] + <span class="built_in">strlen</span>(envp[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        SPT是一个全局变量结构体:</span></span><br><span class="line"><span class="comment">        static struct &#123;</span></span><br><span class="line"><span class="comment">            // original value</span></span><br><span class="line"><span class="comment">            const char *arg0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            // title space available</span></span><br><span class="line"><span class="comment">            char *base, *end;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            // pointer to original nul character within base</span></span><br><span class="line"><span class="comment">            char *nul;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            _Bool reset;</span></span><br><span class="line"><span class="comment">            int error;</span></span><br><span class="line"><span class="comment">        &#125; SPT;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 这一步很关键, 将原进程名备份</span></span><br><span class="line">    <span class="keyword">if</span> (!(SPT.arg0 = strdup(argv[<span class="number">0</span>])))</span><br><span class="line">        <span class="keyword">goto</span> syerr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GLIBC__</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        释放跟argv有关的内存</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!(tmp = strdup(program_invocation_name)))</span><br><span class="line">        <span class="keyword">goto</span> syerr;</span><br><span class="line"></span><br><span class="line">    program_invocation_name = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(tmp = strdup(program_invocation_short_name)))</span><br><span class="line">        <span class="keyword">goto</span> syerr;</span><br><span class="line"></span><br><span class="line">    program_invocation_short_name = tmp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __APPLE__</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        释放跟argv有关的内存</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!(tmp = strdup(getprogname())))</span><br><span class="line">        <span class="keyword">goto</span> syerr;</span><br><span class="line"></span><br><span class="line">    setprogname(tmp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        重新设置了env, 具体怎么实现我们等会跳进去看。</span></span><br><span class="line"><span class="comment">        只需要知道, 这个函数执行过以后, 将在新的内存区域</span></span><br><span class="line"><span class="comment">        产生新的environ, 原来的environ内存区域将归base所有</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = spt_copyenv(envp)))</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        重新设置了除argv[0]以外的所有argv, 具体怎么实现我们等会跳进去看。</span></span><br><span class="line"><span class="comment">        只需要知道, 这个函数执行过以后, 将在新的内存区域</span></span><br><span class="line"><span class="comment">        产生新的除argv[0]以外的argv, 原来的argv[1-n]内存区域将归base所有</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = spt_copyargs(argc, argv)))</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        至此, 原来argv environ共有的那片连续内存全部被转换成base, 即</span></span><br><span class="line"><span class="comment">        char*, 也是argv[0], 也就是进程名。argv和environ将不再连续, 新的</span></span><br><span class="line"><span class="comment">        内荣全部由strdup生成</span></span><br><span class="line"><span class="comment">        我们修改进程名, 只需要改SPT-&gt;base就可以了。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    SPT.nul  = nul;</span><br><span class="line">    SPT.base = base;</span><br><span class="line">    SPT.end  = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">syerr:</span><br><span class="line">error = errno;</span><br><span class="line">error:</span><br><span class="line">SPT.error = error;</span><br><span class="line">&#125; <span class="comment">/* spt_init() */</span></span><br></pre></td></tr></table></figure><p>现在我们在<code>setproctitle.c</code>的<code>line 103</code>展开<code>spt_copyenv(envp)</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">spt_copyenv</span><span class="params">(<span class="keyword">char</span> *oldenv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"><span class="keyword">char</span> *eq;</span><br><span class="line"><span class="keyword">int</span> i, error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        如果environ != oldenv则说明environ已经被设置过了</span></span><br><span class="line"><span class="comment">        直接返回成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (environ != oldenv)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        让老的environ失效,但是不释放那片内存</span></span><br><span class="line"><span class="comment">        这个函数有一段血泪史, 等下我们展开</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> ((error = spt_clearenv()))</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        setenv会生成新的environ, 不必手动设置新environ的内存</span></span><br><span class="line"><span class="comment">        注意setenv中取值的写法, 这是c语言优秀的精华</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; oldenv[i]; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(eq = <span class="built_in">strchr</span>(oldenv[i], <span class="string">'='</span>)))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">*eq = <span class="string">'\0'</span>;</span><br><span class="line">error = (<span class="number">0</span> != setenv(oldenv[i], eq + <span class="number">1</span>, <span class="number">1</span>))? errno : <span class="number">0</span>;</span><br><span class="line">*eq = <span class="string">'='</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        如果设置过程中出问题了, 则还原environ的设置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">error:</span><br><span class="line">environ = oldenv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125; <span class="comment">/* spt_copyenv() */</span></span><br></pre></td></tr></table></figure><p>现在我们来述说那段血泪史, 我们在<code>setproctitle.c</code>的<code>line 83</code>展开<code>spt_clearenv();</code>:<br><a href="http://lists.freebsd.org/pipermail/freebsd-stable/2008-June/043136.html" target="_blank" rel="noopener">这里面是redis作者对cleanrenv()最深沉的吐槽</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For discussion on the portability of the various methods, see</span></span><br><span class="line"><span class="comment"> * http://lists.freebsd.org/pipermail/freebsd-stable/2008-June/043136.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    看上面这段注释中的链接, redis作者写了好几种实现方法来兼容macOS和*nix系统, 至今未果</span></span><br><span class="line"><span class="comment">    现在的这段实现里面macOS是问号,但是我亲测it works</span></span><br><span class="line"><span class="comment">    step 1: 扔给系统一个空environ, 让原来的environ失效</span></span><br><span class="line"><span class="comment">    step 2: 再设置新的environ</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">spt_clearenv</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GLIBC__</span></span><br><span class="line">clearenv();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> **tmp;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        及其怪异的写法,其实相当于:</span></span><br><span class="line"><span class="comment">        char * arr[1] = &#123;nullptr&#125;;</span></span><br><span class="line"><span class="comment">        temp = static_cast&lt;char**&gt;(arr);</span></span><br><span class="line"><span class="comment">        environ = temp;</span></span><br><span class="line"><span class="comment">        它的这个写法, 我思考了好久。这里也不得不吐槽, c语言灵活的没边了...</span></span><br><span class="line"><span class="comment">        void *一时爽, 回看火葬场。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (!(tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *tmp)))</span><br><span class="line"><span class="keyword">return</span> errno;</span><br><span class="line"></span><br><span class="line">tmp[<span class="number">0</span>]  = <span class="literal">NULL</span>;</span><br><span class="line">environ = tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="comment">/* spt_clearenv() */</span></span><br></pre></td></tr></table></figure><p>现在我们在<code>setproctitle.c</code>的<code>line 103</code>展开<code>spt_copyargs(argc, argv);</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">spt_copyargs</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tmp;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        除argv[0]以外的所有argv都由strdup重新生成</span></span><br><span class="line"><span class="comment">        注意由strdup生成的char*是需要free的</span></span><br><span class="line"><span class="comment">        redis里由于就在这里用到, 并且这些参数是给系统使用,</span></span><br><span class="line"><span class="comment">        而且所有函数都只调用一次所以就没有free</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc || (i &gt;= argc &amp;&amp; argv[i]); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!argv[i])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(tmp = strdup(argv[i])))</span><br><span class="line"><span class="keyword">return</span> errno;</span><br><span class="line"></span><br><span class="line">argv[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/* spt_copyargs() */</span></span><br></pre></td></tr></table></figure><p>现在我们在<code>setproctitle.c</code>的<code>line 103</code>展开<code>setproctitle(const char fmt, ...)</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SPT_MAXTITLE = 255;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setproctitle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[SPT_MAXTITLE + <span class="number">1</span>]; <span class="comment">/* use buffer in case argv[0] is passed */</span></span><br><span class="line">va_list ap;</span><br><span class="line"><span class="keyword">char</span> *nul;</span><br><span class="line"><span class="keyword">int</span> len, error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SPT.base)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fmt) &#123;</span><br><span class="line">va_start(ap, fmt);</span><br><span class="line">len = vsnprintf(buf, <span class="keyword">sizeof</span> buf, fmt, ap);</span><br><span class="line">va_end(ap);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"%s"</span>, SPT.arg0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">&#123; error = errno; <span class="keyword">goto</span> error; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SPT.reset) &#123;</span><br><span class="line"><span class="built_in">memset</span>(SPT.base, <span class="number">0</span>, SPT.end - SPT.base);</span><br><span class="line">SPT.reset = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(SPT.base, <span class="number">0</span>, spt_min(<span class="keyword">sizeof</span> buf, SPT.end - SPT.base));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        一顿操作base nul end。终于通过memcpy将我们的新进程名设置进去了</span></span><br><span class="line"><span class="comment">        其实我觉得nul用的没有意义...</span></span><br><span class="line"><span class="comment">        也可能是有序的代码里面会用到?(如果有的话以后更新)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">len = spt_min(len, spt_min(<span class="keyword">sizeof</span> buf, SPT.end - SPT.base) - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(SPT.base, buf, len);</span><br><span class="line">nul = &amp;SPT.base[len];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nul &lt; SPT.nul) &#123;</span><br><span class="line">*SPT.nul = <span class="string">'.'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nul == SPT.nul &amp;&amp; &amp;nul[<span class="number">1</span>] &lt; SPT.end) &#123;</span><br><span class="line">*SPT.nul = <span class="string">' '</span>;</span><br><span class="line">*++nul = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">error:</span><br><span class="line">SPT.error = error;</span><br><span class="line">&#125; <span class="comment">/* setproctitle() */</span></span><br></pre></td></tr></table></figure><p>总结起来就是:</p><pre><code>1. 重新修改全局environ指针指向2. 重新修改除argv[0]以外的argv指针指向3. 扩容argv[0]4. 通过修改argv[0]的内容设置进程名不过有一点很费解的是, 理论上来说重新修改argv[0]的指针指向也可以做到修改进程名, 但是我测试了一下发现不行, 猜测可能系统kernel在创建进程时缓存了argv的const指针,所以在修改argv[0]的指针值时不会生效, 这段验证只是猜测, 未经证实, 有待探究。</code></pre><p>最后, 从redis中偷师, 用c++11写了一个header only的设置进程名的小库:<br><a href="https://github.com/zhangyebai/cplusplus-elf/tree/master/process-name/" target="_blank" rel="noopener">setproctitle</a><br>同时该工程下还有以下两个小玩意儿:<br><a href="https://github.com/zhangyebai/cplusplus-elf/tree/master/thread-pool/" target="_blank" rel="noopener">c<ins>11线程池</ins></a> c++11 std::functional lambda<br><a href="https://github.com/zhangyebai/cplusplus-elf/tree/master/elf/" target="_blank" rel="noopener">c11时间库</a> 跨平台, 几乎能支持所有你的习惯来操作时间~</p><p>部分<code>setproctitle</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _UTIL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _UTIL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   //strlen(2) strdup(1)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt; //min(1)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * origin: 进程原始名</span></span><br><span class="line"><span class="comment"> * base: char数组, 存储修改后的进程名</span></span><br><span class="line"><span class="comment"> * nul:</span></span><br><span class="line"><span class="comment"> * end: </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROC_TITLE_INFO</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * origin;</span><br><span class="line">    <span class="keyword">char</span> * base, *nul, *end;</span><br><span class="line">&#125;PTI, *PPTI;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> ** environ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Util() = <span class="keyword">default</span>;</span><br><span class="line">    ~Util() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * gloabl init function, keep it be called only once</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> PPTI <span class="title">init_proc_title_info</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ** envp = environ;</span><br><span class="line">        <span class="keyword">auto</span> base = argv[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == base)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> * end = (&amp;base[<span class="built_in">strlen</span>(base)]) + <span class="number">1</span>; <span class="comment">// +1 for '\0'</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> idx = <span class="number">0</span>; idx &lt; argc || (idx &gt;= argc &amp;&amp; <span class="literal">nullptr</span> != argv[idx]); ++idx)&#123;</span><br><span class="line">            <span class="comment">// 不知道redis为什么这样写, 我猜可能是遇到特殊的argv, 待探索</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == argv[idx] || argv[idx] &lt; end)&#123;    <span class="comment">//注意这里比较的都是指针,不涉及到数据</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end = argv[idx] + <span class="built_in">strlen</span>(argv[idx]) + <span class="number">1</span>; <span class="comment">// +1 for '\0'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> idx = <span class="number">0</span>; <span class="literal">nullptr</span> != envp[idx]; ++idx)&#123;</span><br><span class="line">            <span class="keyword">if</span> (envp[idx] &lt; end)&#123;   <span class="comment">//注意这里比较的都是指针,不涉及到数据</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end = envp[idx] + <span class="built_in">strlen</span>(envp[idx]) + <span class="number">1</span>;    <span class="comment">// +1 for '\0'</span></span><br><span class="line">        &#125;</span><br><span class="line">        PPTI ppti = <span class="keyword">new</span> PTI();</span><br><span class="line">        ppti-&gt;origin = strdup(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == ppti-&gt;origin)&#123;</span><br><span class="line">            <span class="keyword">delete</span> ppti;</span><br><span class="line">            ppti = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> ppti;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __GLIBC__</span></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">elif</span> __APPLE__</span></span><br><span class="line">        <span class="keyword">auto</span> name = strdup(getprogname());</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == name)&#123;</span><br><span class="line">            <span class="built_in">free</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(ppti-&gt;origin));</span><br><span class="line">            <span class="keyword">delete</span> ppti;</span><br><span class="line">            ppti = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> ppti;</span><br><span class="line">        &#125;</span><br><span class="line">        setprogname(name);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span>( !set_new_env(environ) )&#123;</span><br><span class="line">            <span class="built_in">free</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(ppti-&gt;origin));</span><br><span class="line">            <span class="keyword">delete</span> ppti;</span><br><span class="line">            ppti = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> ppti;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !set_new_argv(argc, argv) )&#123;</span><br><span class="line">            <span class="built_in">free</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(ppti-&gt;origin));</span><br><span class="line">            <span class="keyword">delete</span> ppti;</span><br><span class="line">            ppti = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> ppti;</span><br><span class="line">        &#125;</span><br><span class="line">        ppti-&gt;base = base;</span><br><span class="line">        ppti-&gt;end = end;</span><br><span class="line">        <span class="keyword">return</span> ppti;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_proc_title</span><span class="params">(<span class="keyword">const</span> PPTI ppti, <span class="keyword">const</span> <span class="keyword">char</span> * fmt, ...)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == ppti)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == ppti-&gt;base)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        va_list ap;</span><br><span class="line">        <span class="keyword">auto</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> != fmt)&#123;</span><br><span class="line">            va_start(ap, fmt);</span><br><span class="line">            len = vsnprintf(buf, <span class="keyword">sizeof</span> buf, fmt, ap);</span><br><span class="line">            va_end(ap);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"%s"</span>, ppti-&gt;origin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(ppti-&gt;base, <span class="number">0</span>, len + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(ppti-&gt;base, buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">T</span> <span class="title">min</span>(<span class="title">T</span> &amp;&amp; <span class="title">l</span>, <span class="title">T</span> &amp;&amp; <span class="title">r</span>)&#123;</span></span><br><span class="line">        <span class="keyword">return</span> l &gt; r ? r : l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_new_argv</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> idx = <span class="number">1</span>; idx &lt; argc || (idx &gt;= argc &amp;&amp; <span class="literal">nullptr</span> != argv[idx]); ++idx)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == argv[idx])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> arg = strdup(argv[idx]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == arg)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            argv[idx] = arg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_new_env</span><span class="params">(<span class="keyword">char</span> ** old_env)</span></span>&#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">char</span> ** environ;</span><br><span class="line">        <span class="keyword">if</span>( environ != old_env)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(! clear_env())&#123;</span><br><span class="line">            environ = old_env;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> * eq = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> idx = <span class="number">0</span>; <span class="literal">nullptr</span> != old_env[idx]; ++idx)&#123;</span><br><span class="line">            eq = <span class="built_in">strchr</span>(old_env[idx], <span class="string">'='</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == eq)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *eq = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">int</span> result = setenv(old_env[idx], eq + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">            *eq = <span class="string">'='</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> != result)&#123;</span><br><span class="line">                environ = old_env;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">clear_env</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __GLIBC__</span></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">char</span> ** environ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 相当于 char * arr[1] = &#123;nullptr&#125;;</span></span><br><span class="line"><span class="comment">         * static char ** temp_env = statc_cast&lt;char **&gt;(arr);</span></span><br><span class="line"><span class="comment">         * 其主要目的是为了使environ变成空置,从而使environ失效</span></span><br><span class="line"><span class="comment">         * 关于这个函数的实现请点击下面的链接查看redis作者对其的说明和吐槽</span></span><br><span class="line"><span class="comment">         * For discussion on the portability of the various methods, see</span></span><br><span class="line"><span class="comment">         * http://lists.freebsd.org/pipermail/freebsd-stable/2008-June/043136.html</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> ** temp_env = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> **&gt;(<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *temp_env));</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == temp_env)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp_env[<span class="number">0</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">        environ = temp_env;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./common/Util.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define UNUSED(x) (void)x;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ppti = Util::init_proc_title_info( argc, argv);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ppti-&gt;origin &lt;&lt; <span class="string">"-"</span> &lt;&lt; ppti-&gt;base &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Util::set_proc_title(ppti, <span class="string">"%s-%d"</span>, <span class="string">"named"</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getprogname() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getprogname() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ppti-&gt;end - ppti-&gt;base &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -Wall -std=c++11 -O3 main.cpp -o <span class="built_in">test</span></span><br><span class="line">./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep named</span><br><span class="line">501 99907 50309   0  1:49AM ttys002    0:00.00 named-1</span><br><span class="line">q</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;linux-macos下设置进程名&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux-macos下设置进程名&quot;&gt;&lt;/a&gt; linux macOS下设置进程名&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;base on redis source code 5.0.3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在redis server启动过程中, 有一个宏和一个函数显得很奇特, 他们是&lt;code&gt;server.c&lt;/code&gt;中&lt;code&gt;main()&lt;/code&gt;函数&lt;br&gt;
中的第一个宏和第一个函数, 宏&lt;code&gt;INIT_SETPROCTITLE_REPLACEMENT&lt;/code&gt;和函数&lt;code&gt;spt_init(argc, argv);&lt;/code&gt;.&lt;br&gt;
他俩组合在一起的主要功能是在macOS和*nix下设置(修改)redis的各个进程名, 例如&lt;code&gt;redis-aof-rewrite&lt;/code&gt;、&lt;br&gt;
&lt;code&gt;redis-rdb-bgsave&lt;/code&gt;等。&lt;br&gt;
那么他们是如何工作的呢?想知道这些, 这得从main函数说起。请看标准的main函数签名:&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; ** argv)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="源码趣闻" scheme="http://www.zhangyebai.com/categories/%E6%BA%90%E7%A0%81%E8%B6%A3%E9%97%BB/"/>
    
    
      <category term="redis" scheme="http://www.zhangyebai.com/tags/redis/"/>
    
      <category term="c" scheme="http://www.zhangyebai.com/tags/c/"/>
    
      <category term="c++" scheme="http://www.zhangyebai.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>格式化输出字典 —— 编程之禅 —— 一行代码系列</title>
    <link href="http://www.zhangyebai.com/2019/02/14/python-zen-format-dict-one-word/"/>
    <id>http://www.zhangyebai.com/2019/02/14/python-zen-format-dict-one-word/</id>
    <published>2019-02-14T15:23:20.000Z</published>
    <updated>2019-02-14T15:57:43.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="the-zen-of-python-one-line-code"><a class="markdownIt-Anchor" href="#the-zen-of-python-one-line-code"></a> The Zen of Python: One Line Code</h3><blockquote><p>今天有一位Python刚入门的女性朋友请教我一个问题: 有一个list, 其中存储的是dict, 每个dict<br>的key是相同的,dict的值是整型数值, 请用Python代码将其输出成表格格式。例如:</p></blockquote><pre><code>[{'a': 1, 'b': 2, 'c': 3}, {'a': 4, 'b': 5, 'c': 6}, {'a': 7, 'b': 8, 'c': 9}]=&gt; a b c   1 2 3   4 5 6   7 8 9</code></pre><p>其实是很简单的需求, 后来仔细琢磨想起逛知乎时大家晒的一行代码,决定尝试一下。刚开始思考从各种iterator入手<br>做处理, 尝试了很久不得其法。由于这两年写Java写的太多,灵光一闪想到functional program中各种apply、map、<br>reduce、filter等函数式写法, 一查之下Python果然有这种写法,遂得之。代码如下</p><h3 id="one-line-code"><a class="markdownIt-Anchor" href="#one-line-code"></a> One Line Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format</span><span class="params">(lst: list)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\n'</span>.join([<span class="string">' '</span>.join(lst[<span class="number">0</span>]), <span class="string">'\n'</span>.join(map(<span class="keyword">lambda</span> d : <span class="string">' '</span>.join([str(x) <span class="keyword">for</span> x <span class="keyword">in</span> d.values()]), lst))])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'b'</span>: <span class="number">5</span>, <span class="string">'c'</span>: <span class="number">6</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">7</span>, <span class="string">'b'</span>: <span class="number">8</span>, <span class="string">'c'</span>: <span class="number">9</span>&#125;]</span><br><span class="line">    print(format(data))</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="origin-code"><a class="markdownIt-Anchor" href="#origin-code"></a> Origin Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format</span><span class="params">(lst: list)</span> -&gt; str:</span></span><br><span class="line">    header = <span class="string">' '</span>.join(lst[<span class="number">0</span>])</span><br><span class="line">    store = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">        store.append(<span class="string">' '</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> item.values()))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\n'</span>.join([header, <span class="string">'\n'</span>.join(store)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'b'</span>: <span class="number">5</span>, <span class="string">'c'</span>: <span class="number">6</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">7</span>, <span class="string">'b'</span>: <span class="number">8</span>, <span class="string">'c'</span>: <span class="number">9</span>&#125;]</span><br><span class="line">    print(format(data))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;the-zen-of-python-one-line-code&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#the-zen-of-python-one-line-code&quot;&gt;&lt;/a&gt; The Zen of Python: One Line Code&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;今天有一位Python刚入门的女性朋友请教我一个问题: 有一个list, 其中存储的是dict, 每个dict&lt;br&gt;
的key是相同的,dict的值是整型数值, 请用Python代码将其输出成表格格式。例如:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;[{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}, {&#39;a&#39;: 4, &#39;b&#39;: 5, &#39;c&#39;: 6}, {&#39;a&#39;: 7, &#39;b&#39;: 8, &#39;c&#39;: 9}]
=&amp;gt; a b c
   1 2 3
   4 5 6
   7 8 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实是很简单的需求, 后来仔细琢磨想起逛知乎时大家晒的一行代码,决定尝试一下。刚开始思考从各种iterator入手&lt;br&gt;
做处理, 尝试了很久不得其法。由于这两年写Java写的太多,灵光一闪想到functional program中各种apply、map、&lt;br&gt;
reduce、filter等函数式写法, 一查之下Python果然有这种写法,遂得之。代码如下&lt;/p&gt;
&lt;h3 id=&quot;one-line-code&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#one-line-code&quot;&gt;&lt;/a&gt; One Line Code&lt;/h3&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#! /usr/bin/env python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(lst: list)&lt;/span&gt; -&amp;gt; str:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;.join([&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;.join(lst[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), &lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;.join(map(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; d : &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;.join([str(x) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; d.values()]), lst))])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&#39;__main__&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    data = [&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(format(data))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程之禅" scheme="http://www.zhangyebai.com/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%A6%85/"/>
    
    
      <category term="Python" scheme="http://www.zhangyebai.com/tags/Python/"/>
    
      <category term="zen" scheme="http://www.zhangyebai.com/tags/zen/"/>
    
  </entry>
  
  <entry>
    <title>手写线程池 modern-cpluscplus-threadpool</title>
    <link href="http://www.zhangyebai.com/2019/02/14/modern-cpluscplus-threadpool/"/>
    <id>http://www.zhangyebai.com/2019/02/14/modern-cpluscplus-threadpool/</id>
    <published>2019-02-14T06:38:00.000Z</published>
    <updated>2019-02-14T15:42:24.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c线程池"><a class="markdownIt-Anchor" href="#c线程池"></a> C++线程池</h2><blockquote><p>进程的创建和销毁,代价是昂贵的,除去操作系统的实现及其本身的原理,跟线程相比它更显得重量级。<br>这几年互联网的迅速发展,让线程正面临着跟进程一样的“重量级”困扰。尤其是GO等语言推出协程(纤程)<br>后,线程更是不堪其重。那么有没有改进的方向呢？有,将线程池化——线程池。</p></blockquote><p>由于C++版本推进的历程(<code>C++98</code>, <code>C++03</code>, <code>C++11</code>, <code>C++14</code>, <code>C++17</code>, <code>C++20</code>)以及其<br>弱鸡般的ABI兼容性,导致很多框架用起来得自己造轮子。C++版本再吐槽一句好了, C++即使版本推进到<br>0xff, 对很多人来说还是c with class, 包括我。<br>我们的目标是, 造一个很Java中的ThreadPool类似的线程池。目前的进度:</p><ul><li>[x] 极其简易的线程池(header only)</li><li>[x] 支持设置线程池核心线程数</li><li>[ ] 支持设置线程池最大线程数</li><li>[ ] 支持设置最大缓存的任务数</li><li>[ ] 支持设置任务提交拒绝策略</li></ul><a id="more"></a><p>线程池中的概念:</p><ul><li>job: 需要在线程中执行的代码<ul><li>例如: void read(const string &amp; path, const HANDLE handle);</li><li>该函数从文本中读取内容然后交给窗口渲染到界面上</li></ul></li><li>task: 将job封装成一个task, 由于job的函数签名各异,所以需要封装(Java的job是Runnable,接口签名一致)。<ul><li>例如: auto task = [=]()-&gt;void { return read(path, handle); }</li><li>这样就将签名各异的job统一封装成了std::function&lt;void()&gt;类型的task</li><li>通过std::packaged_task和std::future处理job被异步调用的返回值</li></ul></li><li>queue: 缓存task的队列, 队列操作和线程池中的线程耦合度很高, 原因如下:<ul><li>队列中的任务少时, 池中的空闲线程如何做到真正的不占用cpu?<ul><li>目前此项目是通过std::condition_variable的条件判断让空闲线程阻塞从而让出cpu</li><li>Java中是通过实现BlockQueue实现的,也就是队列中没有任务时,线程从队列中get会阻塞, 从而让出cpu</li><li>也可以通过信号量 互斥量实现</li></ul></li><li>队列read write操作时, 可根据现实情况实现读优先、写优先的锁来平衡队列task的生产和消费, 目前此项目不支持</li><li>设置queue的最大缓存task数</li><li>为什么采取队列, 是为了保证task被执行的优先级(队列可以保证先提交的task被先执行,但是不保证先提交的task被先执行完)</li></ul></li><li>thread: 采用C++11 标准库中的std::thread<ul><li>根据std::thread::hardware_concurrency()获取cpu数量进行任务cpu友好性优化, 目前此项目不支持</li><li>设置thread的cpu亲和性优化程序执行（Windows平台:通过SetThreadAffinityMask指定线程在cpu哪个核心上运行）</li></ul></li></ul><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h3><p><a href="https://github.com/zhangyebai/cplusplus-elf/tree/master/thread-pool" target="_blank" rel="noopener">Code On GitHub</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 几个需要注意的点:</span></span><br><span class="line"><span class="comment"> * 1、tasks的读写锁需要优化成带优先级的锁, 可以肯定线程池的绝大部分使用场景commit task比run task更密集</span></span><br><span class="line"><span class="comment"> * 2、根据tasks以及cpu扩展线程数</span></span><br><span class="line"><span class="comment"> * 3、支持允许缓存的task数,如果超出此数将采取拒绝策略</span></span><br><span class="line"><span class="comment"> * 4、拒绝策略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    ThreadPool(<span class="keyword">int</span> core, <span class="keyword">int</span> max = <span class="number">0</span>, <span class="keyword">int</span> cache = <span class="number">0</span>): core(core),<span class="comment">//由于max和cache暂时没用到,因此赋值0</span></span><br><span class="line">                    max(max), cache(cache), quit(<span class="literal">false</span>), force(<span class="literal">false</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    ~ThreadPool()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;quit.store(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;enable.notify_all();</span><br><span class="line">        <span class="built_in">std</span>::for_each(<span class="keyword">this</span>-&gt;pool.begin(), <span class="keyword">this</span>-&gt;pool.end(), [](<span class="built_in">std</span>::thread &amp; t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.joinable())&#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> idx = <span class="number">0</span>; idx &lt; core; ++idx)&#123;</span><br><span class="line">            pool.push_back(<span class="built_in">std</span>::thread([<span class="keyword">this</span>]()&#123;</span><br><span class="line">                <span class="comment">// 第一次退出,判断是否要强制退出</span></span><br><span class="line">                <span class="keyword">bool</span> quit = <span class="keyword">this</span>-&gt;force.load() ? <span class="keyword">this</span>-&gt;quit.load() : <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(; !quit;)&#123;</span><br><span class="line">                    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">this</span>-&gt;oper_lock);</span><br><span class="line">                    <span class="keyword">this</span>-&gt;enable.wait(lock, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;quit.load() || !<span class="keyword">this</span>-&gt;tasks.empty();</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">// 不是强制退出时可从这里退出</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;quit.load() &amp;&amp; <span class="keyword">this</span>-&gt;tasks.empty())&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task = <span class="built_in">std</span>::move(<span class="keyword">this</span>-&gt;tasks.front());</span><br><span class="line">                    <span class="keyword">this</span>-&gt;tasks.pop();</span><br><span class="line"></span><br><span class="line">                    task();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">bool</span> force = <span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;quit.store(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;force.store(force);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//void commit(std::function&lt;void (void * param)&gt; task);</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">auto</span> <span class="title">commit</span>(<span class="title">T</span> &amp;&amp; <span class="title">t</span>, <span class="title">Args</span>&amp;&amp;...<span class="title">args</span>)-&gt;<span class="title">std</span>:</span>:future&lt;<span class="keyword">decltype</span>(t(args...))&gt;&#123;</span><br><span class="line">        <span class="keyword">using</span> TYPE = <span class="keyword">decltype</span>(t(args...));</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;quit.load())&#123;</span><br><span class="line">            <span class="comment">//dont know return what, so throw an exception</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"thread pool is alreay shutdown."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1、std::packaged_task&lt;decltype(f(args...))() 类似std::function\</span></span><br><span class="line">            但是会将其封装的可调用元素的结果封装在<span class="built_in">std</span>::future中</span><br><span class="line">        <span class="comment">// 2、std::make_shared 创建std::packaged_task&lt;decltype(f(args...))()\</span></span><br><span class="line">            类型的智能指针</span><br><span class="line">        <span class="comment">// 3、std::bind(std::forward&lt;T&gt;(t), std::forward&lt;Args&gt;(args)...)当做\</span></span><br><span class="line">            <span class="built_in">std</span>::packaged_task的构造参数</span><br><span class="line">        <span class="keyword">auto</span> task = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::packaged_task&lt;TYPE()&gt; &gt;( </span><br><span class="line">            <span class="built_in">std</span>::bind(<span class="built_in">std</span>::forward&lt;T&gt;(t), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">std</span>::future&lt;TYPE&gt; result = task-&gt;get_future();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">this</span>-&gt;oper_lock);</span><br><span class="line">        <span class="comment">//将packaged_task 包裹在一个签名为void()的lambda函数中调用,因为此lambda函数符合std::function&lt;void()&gt;\</span></span><br><span class="line">            的签名,所以可以放到<span class="built_in">queue</span>中</span><br><span class="line">        <span class="keyword">this</span>-&gt;tasks.emplace([task]()&#123;</span><br><span class="line">            (*task)();  <span class="comment">//调用packaged_task</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>-&gt;enable.notify_one();  <span class="comment">// 在线程池中唤醒一个休眠的线程</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//void move();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; pool;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; &gt; tasks;</span><br><span class="line">    <span class="keyword">int</span> core;   <span class="comment">//线程池核心线程数</span></span><br><span class="line">    <span class="keyword">int</span> max;    <span class="comment">//线程池根据tasks量以及cpu数最大可扩展的量</span></span><br><span class="line">    <span class="keyword">int</span> cache;  <span class="comment">//运行tasks可缓存的最大task数,超出次数后commit将采取拒绝策略</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; quit;     <span class="comment">//线程池shutdown条件, true时shutdown</span></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; force;    <span class="comment">//是否强制shutdown,true时有剩余的task将不执行直接退出, false时等待执行完所有的task再退出</span></span><br><span class="line">    <span class="built_in">std</span>::condition_variable enable;     <span class="comment">//</span></span><br><span class="line">    <span class="built_in">std</span>::mutex oper_lock;   <span class="comment">// queue的读写锁</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="test-code"><a class="markdownIt-Anchor" href="#test-code"></a> Test Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./pool/ThreadPool.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    pool.start();</span><br><span class="line">    <span class="built_in">std</span>::default_random_engine rd;</span><br><span class="line">    <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; rang(<span class="number">100</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="number">20</span>; ++idx)&#123;</span><br><span class="line">        pool.commit([=](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread id : "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() </span><br><span class="line">                &lt;&lt; <span class="string">" x = "</span> &lt;&lt; x &lt;&lt; <span class="string">" y = "</span> &lt;&lt; y &lt;&lt;</span><br><span class="line">                <span class="string">" sleep time = "</span> &lt;&lt; t &lt;&lt; <span class="string">" ms"</span> &lt;&lt;</span><br><span class="line">                <span class="string">" id = "</span> &lt;&lt; idx &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(t));</span><br><span class="line">        &#125;, rang(rd), rang(rd), rang(rd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; &gt; results;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> index = <span class="number">20</span>; index &lt; <span class="number">50</span>; ++index)&#123;</span><br><span class="line">        results.push_back(</span><br><span class="line">            pool.commit([=]()-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp; r : results)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"get result from thread "</span></span><br><span class="line">        &lt;&lt; <span class="string">" index = "</span> &lt;&lt; r.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> command = <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="string">'q'</span>)&#123;</span><br><span class="line">        pool.shutdown(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">'e'</span>)&#123;</span><br><span class="line">        pool.shutdown(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            pool.commit([]()&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i want to get an exception"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test finish, OY!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compile-link"><a class="markdownIt-Anchor" href="#compile-link"></a> Compile &amp; Link</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -O3 -Wall -std=c++11 main.cpp -o ./out/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="run"><a class="markdownIt-Anchor" href="#run"></a> Run</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">thread id : 0x70000a352000 x = 242 y = 937 sleep time = 480 ms id = 0</span><br><span class="line">thread id : 0x70000a352000 x = 340 y = 390 sleep time = 692 ms id = 1</span><br><span class="line">thread id : 0x70000a352000 x = 188 y = 294 sleep time = 738 ms id = 2</span><br><span class="line">thread id : 0x70000a352000 x = 390 y = 978 sleep time = 270 ms id = 3</span><br><span class="line">thread id : 0x70000a4db000 x = 432 y = 780 sleep time = 102 ms id = 4</span><br><span class="line">thread id : 0x70000a458000 x = 652 y = 661 sleep time = 498 ms id = 5</span><br><span class="line">thread id : 0x70000a3d5000 x = 839 y = 452 sleep time = 487 ms id = 6</span><br><span class="line">thread id : 0x70000a352000 x = 698 y = 540 sleep time = 183 ms id = 7</span><br><span class="line">thread id : 0x70000a4db000 x = 157 y = 983 sleep time = 638 ms id = 8</span><br><span class="line">thread id : 0x70000a3d5000 x = 232 y = 823 sleep time = 766 ms id = 9</span><br><span class="line">thread id : 0x70000a458000 x = 801 y = 411 sleep time = 314 ms id = 10</span><br><span class="line">thread id : 0x70000a458000 x = 359 y = 912 sleep time = 294 ms id = 11</span><br><span class="line">thread id : 0x70000a458000 x = 260 y = 142 sleep time = 372 ms id = 12</span><br><span class="line">thread id : 0x70000a458000 x = 618 y = 499 sleep time = 831 ms id = 13</span><br><span class="line">thread id : 0x70000a458000 x = 108 y = 319 sleep time = 376 ms id = 14</span><br><span class="line">thread id : 0x70000a3d5000 x = 870 y = 490 sleep time = 519 ms id = 15</span><br><span class="line">thread id : 0x70000a352000 x = 446 y = 998 sleep time = 496 ms id = 16</span><br><span class="line">thread id : 0x70000a3d5000 x = 321 y = 308 sleep time = 610 ms id = 17</span><br><span class="line">thread id : 0x70000a3d5000 x = 247 y = 256 sleep time = 629 ms id = 18</span><br><span class="line">thread id : 0x70000a3d5000 x = 186 y = 484 sleep time = 703 ms id = 19</span><br><span class="line">get result from thread  index = 20</span><br><span class="line">get result from thread  index = 21</span><br><span class="line">get result from thread  index = 22</span><br><span class="line">get result from thread  index = 23</span><br><span class="line">get result from thread  index = 24</span><br><span class="line">get result from thread  index = 25</span><br><span class="line">get result from thread  index = 26</span><br><span class="line">get result from thread  index = 27</span><br><span class="line">get result from thread  index = 28</span><br><span class="line">get result from thread  index = 29</span><br><span class="line">get result from thread  index = 30</span><br><span class="line">get result from thread  index = 31</span><br><span class="line">get result from thread  index = 32</span><br><span class="line">get result from thread  index = 33</span><br><span class="line">get result from thread  index = 34</span><br><span class="line">get result from thread  index = 35</span><br><span class="line">get result from thread  index = 36</span><br><span class="line">get result from thread  index = 37</span><br><span class="line">get result from thread  index = 38</span><br><span class="line">get result from thread  index = 39</span><br><span class="line">get result from thread  index = 40</span><br><span class="line">get result from thread  index = 41</span><br><span class="line">get result from thread  index = 42</span><br><span class="line">get result from thread  index = 43</span><br><span class="line">get result from thread  index = 44</span><br><span class="line">get result from thread  index = 45</span><br><span class="line">get result from thread  index = 46</span><br><span class="line">get result from thread  index = 47</span><br><span class="line">get result from thread  index = 48</span><br><span class="line">get result from thread  index = 49</span><br><span class="line">e</span><br><span class="line">thread pool is alreay shutdown.</span><br><span class="line">test finish, OY!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;c线程池&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c线程池&quot;&gt;&lt;/a&gt; C++线程池&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;进程的创建和销毁,代价是昂贵的,除去操作系统的实现及其本身的原理,跟线程相比它更显得重量级。&lt;br&gt;
这几年互联网的迅速发展,让线程正面临着跟进程一样的“重量级”困扰。尤其是GO等语言推出协程(纤程)&lt;br&gt;
后,线程更是不堪其重。那么有没有改进的方向呢？有,将线程池化——线程池。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于C++版本推进的历程(&lt;code&gt;C++98&lt;/code&gt;, &lt;code&gt;C++03&lt;/code&gt;, &lt;code&gt;C++11&lt;/code&gt;, &lt;code&gt;C++14&lt;/code&gt;, &lt;code&gt;C++17&lt;/code&gt;, &lt;code&gt;C++20&lt;/code&gt;)以及其&lt;br&gt;
弱鸡般的ABI兼容性,导致很多框架用起来得自己造轮子。C++版本再吐槽一句好了, C++即使版本推进到&lt;br&gt;
0xff, 对很多人来说还是c with class, 包括我。&lt;br&gt;
我们的目标是, 造一个很Java中的ThreadPool类似的线程池。目前的进度:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[x] 极其简易的线程池(header only)&lt;/li&gt;
&lt;li&gt;[x] 支持设置线程池核心线程数&lt;/li&gt;
&lt;li&gt;[ ] 支持设置线程池最大线程数&lt;/li&gt;
&lt;li&gt;[ ] 支持设置最大缓存的任务数&lt;/li&gt;
&lt;li&gt;[ ] 支持设置任务提交拒绝策略&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="FrameWork" scheme="http://www.zhangyebai.com/categories/FrameWork/"/>
    
    
      <category term="C++" scheme="http://www.zhangyebai.com/tags/C/"/>
    
      <category term="线程" scheme="http://www.zhangyebai.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://www.zhangyebai.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 053 - Maximum-Sub-Array</title>
    <link href="http://www.zhangyebai.com/2019/02/12/maximum-sub-array/"/>
    <id>http://www.zhangyebai.com/2019/02/12/maximum-sub-array/</id>
    <published>2019-02-12T13:37:45.000Z</published>
    <updated>2019-02-12T14:45:46.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">官方地址</a></p><ul><li><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></li><li><p>示例:</p></li><li><p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p></li><li><p>输出: 6</p></li><li><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></li><li><p>进阶:</p></li><li><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><pre><code> 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法…… 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。</code></pre></li></ul><a id="more"></a><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> Java Solution</h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><ul><li>✔ Accepted</li><li>✔ 202/202 cases passed (16 ms)</li><li>✔ Your runtime beats 31.02 % of java submissions</li><li>✔ 2019-02-12 21:31:45</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];  <span class="comment">//sum保存着跟随idx遍历nums每个索引为结束位置的最大值（不是太好理解）</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];  <span class="comment">//max保存着idx及其以前的元素为结束位置的最大值</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt; nums.length; ++idx)&#123;   <span class="comment">//注意idx从1开始,因为sum和max不能初始化为0,</span></span><br><span class="line">                                                    <span class="comment">//只能初始化为nums[0],因为nums中的元素可能是负数</span></span><br><span class="line">            sum = Math.max(sum + nums[idx], nums[idx]); <span class="comment">//注意sum是以idx索引元素为结束位置的最大值（包含idx）</span></span><br><span class="line">            max = Math.max(sum, max);   <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    (max: 全局的最大值,也就是我们要求的结果; sum: 局部最大值,代表的是以某元素结尾的最大值)    -1 2 -3 4 -1    idx = 0: sum = -1, max = -1 (注: 此步骤即是初始化sum和max, 也就是第一个元素为结尾的局部最大值和全局最大值)    idx = 1: sum = (-1 + 2), max = sum = 1    idx = 2: sum = (1 + -3), max = 1    idx = 3: sum = 4, max = sum = 4    idx = 4: sum = (4 + -1), max = 4    所以求得结果max=4    注意到此题有dp解法,后续增加</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;description&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#description&quot;&gt;&lt;/a&gt; Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方地址&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出: 6&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进阶:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法……
 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 002 - Add Two Numbers (Medium)</title>
    <link href="http://www.zhangyebai.com/2017/02/19/add-two-numbers/"/>
    <id>http://www.zhangyebai.com/2017/02/19/add-two-numbers/</id>
    <published>2017-02-19T07:08:44.000Z</published>
    <updated>2019-02-12T14:51:34.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="descripiton"><a class="markdownIt-Anchor" href="#descripiton"></a> Descripiton</h2><pre><code>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in  reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。  这句话什么意思呢？换句话说就是这样：  比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4);19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1);因为表示顺序是反着的，所以进位也是反着的。假设这两个数字不包含任何的头结点0，除了数字0本身。</code></pre><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8</code></pre><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><pre><code>通过描述中的大致分析可以看出，需要遍历两个Linked-List中的对应的Node并取数相加，然后生成新Node并添加到result的Link-List中。- 2个Linked-List中对应的Node，如果有一个为null，一个不为null，则结果节点直接使用不为null的Node中的值去构造即可;- 如果两个Node相加需要进位，切记是向后进位，如果有后续Node，计算是需要加上进位;- 如果两个Node相加需要进位，且没有后续Node，则需要添加一个Node，值用进位的数即可;- 以下代码截止到提交日期，均已被LeetCode AC；</code></pre><h2 id="python-solution"><a class="markdownIt-Anchor" href="#python-solution"></a> <code>Python Solution</code></h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Node定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LeetCode的命名规范我已经无力吐槽了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            :type l1: ListNode</span></span><br><span class="line"><span class="string">            :type l2: ListNode</span></span><br><span class="line"><span class="string">            :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = ListNode(<span class="number">0</span>)</span><br><span class="line">        step = result</span><br><span class="line">        l_hand, r_hand = l1, l2</span><br><span class="line">        node_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">or</span> r_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            node_sum //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> l_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                node_sum += l_hand.val</span><br><span class="line">                l_hand = l_hand.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                node_sum += r_hand.val</span><br><span class="line">                r_hand = r_hand.next</span><br><span class="line"></span><br><span class="line">            step.next = ListNode(node_sum % <span class="number">10</span>)</span><br><span class="line">            step = step.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node_sum // <span class="number">10</span> &gt; <span class="number">0</span>:</span><br><span class="line">            step.next = ListNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.next</span><br><span class="line"><span class="comment">#TestCase</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_node</span><span class="params">(param)</span>-&gt;ListNode:</span></span><br><span class="line">    result_node, temp_node = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> param:</span><br><span class="line">        <span class="keyword">if</span> result_node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            temp_node = ListNode(value)</span><br><span class="line">            result_node = temp_node</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        temp_node.next = ListNode(value)</span><br><span class="line">        temp_node = temp_node.next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_node</span><span class="params">(param_node: ListNode)</span>-&gt;<span class="keyword">None</span>:</span></span><br><span class="line">    temp_node, values = param_node, []</span><br><span class="line">    <span class="keyword">while</span> temp_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        values.append(str(temp_node.val))</span><br><span class="line">        temp_node = temp_node.next</span><br><span class="line">    print(<span class="string">'['</span>, <span class="string">'-&gt;'</span>.join(values), <span class="string">']'</span>, sep=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l_node = init_node([<span class="number">3</span>, <span class="number">7</span>])</span><br><span class="line">    r_node = init_node([<span class="number">9</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    print_node(Solution().add_two_nums(l_node, r_node))</span><br></pre></td></tr></table></figure><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> <code>Java Solution</code></h2><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode step = result;</span><br><span class="line">        ListNode l_hand = l1;</span><br><span class="line">        ListNode r_hand = l2;</span><br><span class="line">        <span class="keyword">int</span> node_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;l_hand != <span class="keyword">null</span> || r_hand != <span class="keyword">null</span>;)&#123;</span><br><span class="line">            node_sum /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (l_hand != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node_sum += l_hand.val;</span><br><span class="line">                l_hand = l_hand.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r_hand !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                node_sum += r_hand.val;</span><br><span class="line">                r_hand = r_hand.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            step.next = <span class="keyword">new</span> ListNode(node_sum % <span class="number">10</span>);</span><br><span class="line">            step = step.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node_sum / <span class="number">10</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            step.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TestCase</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(node.val);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不要问我这两个数组时哪里来的，没有错误的程序是不会知道的</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = &#123;<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        printNode(<span class="keyword">new</span> AddTwoNumbers().addTwoNumbers(initList(arr1), initList(arr2)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-solution"><a class="markdownIt-Anchor" href="#c-solution"></a> <code>C++ Solution</code></h2><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTwoNumbers</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">ListNode *step = &amp;head, *l_hand = l1, *r_hand = l2;</span><br><span class="line"><span class="keyword">int</span> node_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; l_hand || r_hand;) </span><br><span class="line">&#123;</span><br><span class="line">node_sum /= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (l_hand) </span><br><span class="line">&#123;</span><br><span class="line">node_sum += l_hand-&gt;val;</span><br><span class="line">l_hand = l_hand-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r_hand) </span><br><span class="line">&#123;</span><br><span class="line">node_sum += r_hand-&gt;val;</span><br><span class="line">r_hand = r_hand-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">step-&gt;next = <span class="keyword">new</span> ListNode(node_sum % <span class="number">10</span>);</span><br><span class="line">step = step-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node_sum / <span class="number">10</span> &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">step-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;descripiton&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#descripiton&quot;&gt;&lt;/a&gt; Descripiton&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in  
reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。  
这句话什么意思呢？换句话说就是这样：  
	比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&amp;gt;Node(1) + Node(1)-&amp;gt;Node(2) = Node(0)-&amp;gt;Node(4);
	19 + 91 = 110就表示为Node(9)-&amp;gt;Node(1) + Node(1)-&amp;gt;Node(9) = Node(0)-&amp;gt;Node(1)-&amp;gt;Node(1);
	因为表示顺序是反着的，所以进位也是反着的。
假设这两个数字不包含任何的头结点0，除了数字0本身。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;example&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#example&quot;&gt;&lt;/a&gt; Example&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
Output: 7 -&amp;gt; 0 -&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="Python" scheme="http://www.zhangyebai.com/tags/Python/"/>
    
      <category term="C++" scheme="http://www.zhangyebai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Singleton - 单例模式 - Java</title>
    <link href="http://www.zhangyebai.com/2017/02/13/Singleton/"/>
    <id>http://www.zhangyebai.com/2017/02/13/Singleton/</id>
    <published>2017-02-13T15:48:30.000Z</published>
    <updated>2019-02-12T14:42:52.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2><ul><li><p>One instance of a class or one value accessible globally in an application.</p><ul><li>Ensure that only one instance of a class is created.</li><li>Provide a global point of access to the object.</li></ul></li><li><p>在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点:</p><ul><li>确保该唯一实例被创建。</li><li>为外界使用该实例提供一个全局的访问入口。</li><li>对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。</li></ul></li></ul><a id="more"></a><h2 id="简单懒汉式单例模式"><a class="markdownIt-Anchor" href="#简单懒汉式单例模式"></a> 简单懒汉式单例模式</h2><pre><code>- 简单 * 3，但是致命缺点是线程不安全。- 懒汉式:在Singleton被ClassLoader加载时并不实例化instance，只有在需要时(即调用getInstance方法时)才会触发实例化。- getInstance，newInstance在命名规范上的区别是分别对应单例和多例!</code></pre><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次 3ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRuntime</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> timestart = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, loop = <span class="number">10000000</span>; index &lt; loop; ++index)&#123;</span><br><span class="line">Singleton singletonThread1 = Singleton.getSingletonInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> timeend = System.currentTimeMillis();</span><br><span class="line">System.out.println(timeend - timestart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;Singleton, Integer&gt; hMap = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Singleton singleton = Singleton.getSingletonInstance();</span><br><span class="line">hMap.put(singleton, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*开启了100000个线程测试，并未发现有多个实例的现象，但是此种做法确实是存在多例的风险，原因在于当两个线程同时调用  </span></span><br><span class="line"><span class="comment">getSingletonInstance()且instance都为null时，两个线程可能会同时执行instance = new Singleton();*/</span></span><br></pre></td></tr></table></figure><h2 id="线程安全懒汉式单例模式"><a class="markdownIt-Anchor" href="#线程安全懒汉式单例模式"></a> 线程安全懒汉式单例模式</h2><pre><code>- 通过对全局入口方法加同步来解决线程安全的问题。- 带来的后果是资源的开销是非常大的，因为初始化完instance后不再需要synchronized- 毕竟线程安全了。</code></pre><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> synchroized Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次调用 56ms （简单懒汉式单例模式中为3ms）</span></span><br><span class="line"><span class="comment">//测试代码参考 简单懒汉式单例模式 中代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="comment">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span></span><br></pre></td></tr></table></figure><h2 id="改进效率版懒汉式单例模式"><a class="markdownIt-Anchor" href="#改进效率版懒汉式单例模式"></a> 改进效率版懒汉式单例模式</h2><pre><code>- synchroized 同步方法的资源开销是很大的。- 改进点在于用synchronized同步实例化代码块，这样的好处是一旦实例化完成，以后的调用不会再触碰到synchronized。</code></pre><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton  implements java.io.Serializable&#123;</span><br><span class="line">private volatile static Singleton instance;</span><br><span class="line">private Singleton()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static  Singleton getSingletonInstance()&#123;</span><br><span class="line">if (instance == null)&#123;</span><br><span class="line">synchroized(Singleton.class)&#123;</span><br><span class="line">if(instance == null)&#123;</span><br><span class="line">instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Object readResolve()&#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//RuntimeTestCase 10000000次调用 3ms 理论上来说应该于 简单懒汉式单例模式 中的实现效率持平。</span><br><span class="line">//测试代码参考 简单懒汉式单例模式 中代码</span><br><span class="line"></span><br><span class="line">//MultipleInstanceTestCase</span><br><span class="line">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span><br></pre></td></tr></table></figure><h2 id="饿汉式单例模式"><a class="markdownIt-Anchor" href="#饿汉式单例模式"></a> 饿汉式单例模式</h2><pre><code>- 触发ClassLoader加载该类时实例化。- 与懒汉式的区别是:主动实例化。</code></pre><h3 id="code-4"><a class="markdownIt-Anchor" href="#code-4"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种写法是通过静态代码块实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次调用 2ms。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="comment">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span></span><br></pre></td></tr></table></figure><h2 id="静态内部类实现单例"><a class="markdownIt-Anchor" href="#静态内部类实现单例"></a> 静态内部类实现单例</h2><pre><code>- 实现延迟实例化。- 线程安全。- 推荐使用。</code></pre><h3 id="code-5"><a class="markdownIt-Anchor" href="#code-5"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonController</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonController.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonController.instance;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次调用 3ms 。</span></span><br><span class="line"><span class="comment">//测试代码参考 简单懒汉式单例模式 中代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="comment">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span></span><br></pre></td></tr></table></figure><h2 id="枚举实现"><a class="markdownIt-Anchor" href="#枚举实现"></a> 枚举实现</h2><p>最近在看《Effective java 中文版2th》的时候，看到的此种方法，顿时被惊呆。以下为书中原话:</p><pre><code>- since jdk 1.5 。- 只需编写一个包含单个元素的枚举类型即可实现。- 此方法在功能上与公有域方法接近，但是它更加简洁，无偿地提供了序列化机制。- 绝对的防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。- 虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</code></pre><h3 id="code-6"><a class="markdownIt-Anchor" href="#code-6"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="comment">//代码至此已经完事。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单例模式&quot;&gt;&lt;/a&gt; 单例模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;One instance of a class or one value accessible globally in an application.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ensure that only one instance of a class is created.&lt;/li&gt;
&lt;li&gt;Provide a global point of access to the object.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保该唯一实例被创建。&lt;/li&gt;
&lt;li&gt;为外界使用该实例提供一个全局的访问入口。&lt;/li&gt;
&lt;li&gt;对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://www.zhangyebai.com/categories/Design-Pattern/"/>
    
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://www.zhangyebai.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://www.zhangyebai.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 001 - Two Sum (Easy)</title>
    <link href="http://www.zhangyebai.com/2017/02/13/two-sum/"/>
    <id>http://www.zhangyebai.com/2017/02/13/two-sum/</id>
    <published>2017-02-12T21:02:51.000Z</published>
    <updated>2019-02-12T14:51:39.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="descripiton"><a class="markdownIt-Anchor" href="#descripiton"></a> Descripiton</h2><pre><code>Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。</code></pre><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><ul><li>利用map数据结构的Key-Value键值对的存储特点，遍历array数组时，查看当前数组元素value与目标target的差（<strong>target - value</strong>）是否在map的keys中，如果存在说明前面的遍历时找到了第一个value，取出索引并返回当前索引即可;如果没找到，将当前value作为key，当前索引index作为key的value放置进map继续遍历即可。<ul><li>Python中map数据结构为字典（dict）</li><li>适当关注一下c++中std::map和std::vector的相关操作</li><li>以下代码截止到提交日期，均已被LeetCode AC</li></ul></li></ul><h2 id="python-solution"><a class="markdownIt-Anchor" href="#python-solution"></a> <code>Python Solution</code></h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_num</span><span class="params">(nums, target)</span>-&gt;object:</span></span><br><span class="line">nums_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> loop, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line"><span class="keyword">if</span> nums_dict.__contains__(target - value):</span><br><span class="line"><span class="keyword">return</span> [nums_dict[target - value], loop]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums_dict[value] = loop</span><br><span class="line"></span><br><span class="line"><span class="comment">#TestCase</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num_list = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">    target_num = <span class="number">22</span></span><br><span class="line">    result = Solution().two_num(num_list, target_num)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> result:</span><br><span class="line">            print(<span class="string">'-&gt;'</span>.join([str(index), str(num_list[index])]))</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        print(<span class="string">'no target to find'</span>)</span><br></pre></td></tr></table></figure><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> <code>Java Solution</code></h2><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">Map&amp;ltInteger, Integer&gt; map = <span class="keyword">new</span> HashMap&amp;ltInteger, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>, length = nums.length; index &lt; length; ++index)&#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target - nums[index]))&#123;</span><br><span class="line">    result[<span class="number">0</span>] = map.get(target - nums[index]);</span><br><span class="line">        result[<span class="number">1</span>] = index;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.put(nums[index], index);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-solution"><a class="markdownIt-Anchor" href="#c-solution"></a> <code>C++ Solution</code></h2><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; loop;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> index = <span class="number">0</span>; index &lt; nums.size(); ++index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (loop.find(target - nums.at(index)) != loop.cend())</span><br><span class="line">&#123;</span><br><span class="line">result.push_back(loop.at(target - nums.at(index)));</span><br><span class="line">result.push_back(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">loop.insert(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(nums.at(index), index));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TestCase</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Solution solution;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = solution.twoSum(nums, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = result.begin(); iter != result.end(); ++iter)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> timing = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; timing;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;descripiton&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#descripiton&quot;&gt;&lt;/a&gt; Descripiton&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.

给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。
假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;example&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#example&quot;&gt;&lt;/a&gt; Example&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="Python" scheme="http://www.zhangyebai.com/tags/Python/"/>
    
      <category term="C++" scheme="http://www.zhangyebai.com/tags/C/"/>
    
  </entry>
  
</feed>
