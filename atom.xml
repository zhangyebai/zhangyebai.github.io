<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一码平川</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhangyebai.com/"/>
  <updated>2019-02-12T14:39:39.156Z</updated>
  <id>http://www.zhangyebai.com/</id>
  
  <author>
    <name>张夜白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode - 053 - Maximum-Sub-Array</title>
    <link href="http://www.zhangyebai.com/2019/02/12/maximum-sub-array/"/>
    <id>http://www.zhangyebai.com/2019/02/12/maximum-sub-array/</id>
    <published>2019-02-12T13:37:45.000Z</published>
    <updated>2019-02-12T14:39:39.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">官方地址</a></p><ul><li><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></li><li><p>示例:</p></li><li><p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p></li><li><p>输出: 6</p></li><li><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></li><li><p>进阶:</p></li><li><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><pre><code> 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法…… 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。</code></pre></li></ul><a id="more"></a><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> Java Solution</h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><ul><li>✔ Accepted</li><li>✔ 202/202 cases passed (16 ms)</li><li>✔ Your runtime beats 31.02 % of java submissions</li><li>✔ 2019-02-12 21:31:45</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];  <span class="comment">//sum保存着跟随idx遍历nums每个索引为结束位置的最大值（不是太好理解）</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];  <span class="comment">//max保存着idx及其以前的元素为结束位置的最大值</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt; nums.length; ++idx)&#123;   <span class="comment">//注意idx从1开始,因为sum和max不能初始化为0,</span></span><br><span class="line">                                                    <span class="comment">//只能初始化为nums[0],因为nums中的元素可能是负数</span></span><br><span class="line">            sum = Math.max(sum + nums[idx], nums[idx]); <span class="comment">//注意sum是以idx索引元素为结束位置的最大值（包含idx）</span></span><br><span class="line">            max = Math.max(sum, max);   <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    (max: 全局的最大值,也就是我们要求的结果; sum: 局部最大值,代表的是以某元素结尾的最大值)    -1 2 -3 4 -1    idx = 0: sum = -1, max = -1 (注: 此步骤即是初始化sum和max, 也就是第一个元素为结尾的局部最大值和全局最大值)    idx = 1: sum = (-1 + 2), max = sum = 1    idx = 2: sum = (1 + -3), max = 1    idx = 3: sum = 4, max = sum = 4    idx = 4: sum = (4 + -1), max = 4    所以求得结果max=4    注意到此题有dp解法,后续增加</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;description&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#description&quot;&gt;&lt;/a&gt; Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方地址&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出: 6&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进阶:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 刷知乎忽然看到的一道题,然后上leetcode上看了一下,虽然标记的是easy,但是第一反应居然只想到o(n^3)暴力法……
 仔细思考了好久,才找到o(n)的解法,非奇思妙想不可得。详情请看一下代码注释。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 002 - Add Two Numbers (Medium)</title>
    <link href="http://www.zhangyebai.com/2017/02/19/add-two-numbers/"/>
    <id>http://www.zhangyebai.com/2017/02/19/add-two-numbers/</id>
    <published>2017-02-19T07:08:44.000Z</published>
    <updated>2019-02-12T14:44:10.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="descripiton"><a class="markdownIt-Anchor" href="#descripiton"></a> Descripiton</h2><pre><code>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in  reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。  这句话什么意思呢？换句话说就是这样：  比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4);19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1);因为表示顺序是反着的，所以进位也是反着的。假设这两个数字不包含任何的头结点0，除了数字0本身。</code></pre><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8</code></pre><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><pre><code>通过描述中的大致分析可以看出，需要遍历两个Linked-List中的对应的Node并取数相加，然后生成新Node并添加到result的Link-List中。- 2个Linked-List中对应的Node，如果有一个为null，一个不为null，则结果节点直接使用不为null的Node中的值去构造即可;- 如果两个Node相加需要进位，切记是向后进位，如果有后续Node，计算是需要加上进位;- 如果两个Node相加需要进位，且没有后续Node，则需要添加一个Node，值用进位的数即可;- 以下代码截止到提交日期，均已被LeetCode AC；</code></pre><h2 id="python-solution"><a class="markdownIt-Anchor" href="#python-solution"></a> <code>Python Solution</code></h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Node定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LeetCode的命名规范我已经无力吐槽了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            :type l1: ListNode</span></span><br><span class="line"><span class="string">            :type l2: ListNode</span></span><br><span class="line"><span class="string">            :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = ListNode(<span class="number">0</span>)</span><br><span class="line">        step = result</span><br><span class="line">        l_hand, r_hand = l1, l2</span><br><span class="line">        node_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">or</span> r_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            node_sum //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> l_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                node_sum += l_hand.val</span><br><span class="line">                l_hand = l_hand.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r_hand <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                node_sum += r_hand.val</span><br><span class="line">                r_hand = r_hand.next</span><br><span class="line"></span><br><span class="line">            step.next = ListNode(node_sum % <span class="number">10</span>)</span><br><span class="line">            step = step.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node_sum // <span class="number">10</span> &gt; <span class="number">0</span>:</span><br><span class="line">            step.next = ListNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.next</span><br><span class="line"><span class="comment">#TestCase</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_node</span><span class="params">(param)</span>-&gt;ListNode:</span></span><br><span class="line">    result_node, temp_node = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> param:</span><br><span class="line">        <span class="keyword">if</span> result_node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            temp_node = ListNode(value)</span><br><span class="line">            result_node = temp_node</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        temp_node.next = ListNode(value)</span><br><span class="line">        temp_node = temp_node.next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_node</span><span class="params">(param_node: ListNode)</span>-&gt;<span class="keyword">None</span>:</span></span><br><span class="line">    temp_node, values = param_node, []</span><br><span class="line">    <span class="keyword">while</span> temp_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        values.append(str(temp_node.val))</span><br><span class="line">        temp_node = temp_node.next</span><br><span class="line">    print(<span class="string">'['</span>, <span class="string">'-&gt;'</span>.join(values), <span class="string">']'</span>, sep=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l_node = init_node([<span class="number">3</span>, <span class="number">7</span>])</span><br><span class="line">    r_node = init_node([<span class="number">9</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    print_node(Solution().add_two_nums(l_node, r_node))</span><br></pre></td></tr></table></figure><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> <code>Java Solution</code></h2><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode step = result;</span><br><span class="line">        ListNode l_hand = l1;</span><br><span class="line">        ListNode r_hand = l2;</span><br><span class="line">        <span class="keyword">int</span> node_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;l_hand != <span class="keyword">null</span> || r_hand != <span class="keyword">null</span>;)&#123;</span><br><span class="line">            node_sum /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (l_hand != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node_sum += l_hand.val;</span><br><span class="line">                l_hand = l_hand.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r_hand !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                node_sum += r_hand.val;</span><br><span class="line">                r_hand = r_hand.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            step.next = <span class="keyword">new</span> ListNode(node_sum % <span class="number">10</span>);</span><br><span class="line">            step = step.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node_sum / <span class="number">10</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            step.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TestCase</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(node.val);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不要问我这两个数组时哪里来的，没有错误的程序是不会知道的</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = &#123;<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        printNode(<span class="keyword">new</span> AddTwoNumbers().addTwoNumbers(initList(arr1), initList(arr2)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">      ListNode next;</span><br><span class="line">      ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-solution"><a class="markdownIt-Anchor" href="#c-solution"></a> <code>C++ Solution</code></h2><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTwoNumbers</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">ListNode *step = &amp;head, *l_hand = l1, *r_hand = l2;</span><br><span class="line"><span class="keyword">int</span> node_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; l_hand || r_hand;) </span><br><span class="line">&#123;</span><br><span class="line">node_sum /= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (l_hand) </span><br><span class="line">&#123;</span><br><span class="line">node_sum += l_hand-&gt;val;</span><br><span class="line">l_hand = l_hand-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r_hand) </span><br><span class="line">&#123;</span><br><span class="line">node_sum += r_hand-&gt;val;</span><br><span class="line">r_hand = r_hand-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">step-&gt;next = <span class="keyword">new</span> ListNode(node_sum % <span class="number">10</span>);</span><br><span class="line">step = step-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node_sum / <span class="number">10</span> &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">step-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;descripiton&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#descripiton&quot;&gt;&lt;/a&gt; Descripiton&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in  
reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。  
这句话什么意思呢？换句话说就是这样：  
	比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&amp;gt;Node(1) + Node(1)-&amp;gt;Node(2) = Node(0)-&amp;gt;Node(4);
	19 + 91 = 110就表示为Node(9)-&amp;gt;Node(1) + Node(1)-&amp;gt;Node(9) = Node(0)-&amp;gt;Node(1)-&amp;gt;Node(1);
	因为表示顺序是反着的，所以进位也是反着的。
假设这两个数字不包含任何的头结点0，除了数字0本身。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;example&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#example&quot;&gt;&lt;/a&gt; Example&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
Output: 7 -&amp;gt; 0 -&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
      <category term="Python" scheme="http://www.zhangyebai.com/tags/Python/"/>
    
      <category term="C++" scheme="http://www.zhangyebai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Singleton - 单例模式 - Java</title>
    <link href="http://www.zhangyebai.com/2017/02/13/Singleton/"/>
    <id>http://www.zhangyebai.com/2017/02/13/Singleton/</id>
    <published>2017-02-13T15:48:30.000Z</published>
    <updated>2019-02-12T14:42:52.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2><ul><li><p>One instance of a class or one value accessible globally in an application.</p><ul><li>Ensure that only one instance of a class is created.</li><li>Provide a global point of access to the object.</li></ul></li><li><p>在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点:</p><ul><li>确保该唯一实例被创建。</li><li>为外界使用该实例提供一个全局的访问入口。</li><li>对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。</li></ul></li></ul><a id="more"></a><h2 id="简单懒汉式单例模式"><a class="markdownIt-Anchor" href="#简单懒汉式单例模式"></a> 简单懒汉式单例模式</h2><pre><code>- 简单 * 3，但是致命缺点是线程不安全。- 懒汉式:在Singleton被ClassLoader加载时并不实例化instance，只有在需要时(即调用getInstance方法时)才会触发实例化。- getInstance，newInstance在命名规范上的区别是分别对应单例和多例!</code></pre><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次 3ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRuntime</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> timestart = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, loop = <span class="number">10000000</span>; index &lt; loop; ++index)&#123;</span><br><span class="line">Singleton singletonThread1 = Singleton.getSingletonInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> timeend = System.currentTimeMillis();</span><br><span class="line">System.out.println(timeend - timestart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;Singleton, Integer&gt; hMap = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Singleton singleton = Singleton.getSingletonInstance();</span><br><span class="line">hMap.put(singleton, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*开启了100000个线程测试，并未发现有多个实例的现象，但是此种做法确实是存在多例的风险，原因在于当两个线程同时调用  </span></span><br><span class="line"><span class="comment">getSingletonInstance()且instance都为null时，两个线程可能会同时执行instance = new Singleton();*/</span></span><br></pre></td></tr></table></figure><h2 id="线程安全懒汉式单例模式"><a class="markdownIt-Anchor" href="#线程安全懒汉式单例模式"></a> 线程安全懒汉式单例模式</h2><pre><code>- 通过对全局入口方法加同步来解决线程安全的问题。- 带来的后果是资源的开销是非常大的，因为初始化完instance后不再需要synchronized- 毕竟线程安全了。</code></pre><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> synchroized Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次调用 56ms （简单懒汉式单例模式中为3ms）</span></span><br><span class="line"><span class="comment">//测试代码参考 简单懒汉式单例模式 中代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="comment">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span></span><br></pre></td></tr></table></figure><h2 id="改进效率版懒汉式单例模式"><a class="markdownIt-Anchor" href="#改进效率版懒汉式单例模式"></a> 改进效率版懒汉式单例模式</h2><pre><code>- synchroized 同步方法的资源开销是很大的。- 改进点在于用synchronized同步实例化代码块，这样的好处是一旦实例化完成，以后的调用不会再触碰到synchronized。</code></pre><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton  implements java.io.Serializable&#123;</span><br><span class="line">private volatile static Singleton instance;</span><br><span class="line">private Singleton()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static  Singleton getSingletonInstance()&#123;</span><br><span class="line">if (instance == null)&#123;</span><br><span class="line">synchroized(Singleton.class)&#123;</span><br><span class="line">if(instance == null)&#123;</span><br><span class="line">instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Object readResolve()&#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//RuntimeTestCase 10000000次调用 3ms 理论上来说应该于 简单懒汉式单例模式 中的实现效率持平。</span><br><span class="line">//测试代码参考 简单懒汉式单例模式 中代码</span><br><span class="line"></span><br><span class="line">//MultipleInstanceTestCase</span><br><span class="line">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span><br></pre></td></tr></table></figure><h2 id="饿汉式单例模式"><a class="markdownIt-Anchor" href="#饿汉式单例模式"></a> 饿汉式单例模式</h2><pre><code>- 触发ClassLoader加载该类时实例化。- 与懒汉式的区别是:主动实例化。</code></pre><h3 id="code-4"><a class="markdownIt-Anchor" href="#code-4"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种写法是通过静态代码块实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次调用 2ms。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="comment">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span></span><br></pre></td></tr></table></figure><h2 id="静态内部类实现单例"><a class="markdownIt-Anchor" href="#静态内部类实现单例"></a> 静态内部类实现单例</h2><pre><code>- 实现延迟实例化。- 线程安全。- 推荐使用。</code></pre><h3 id="code-5"><a class="markdownIt-Anchor" href="#code-5"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonController</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getSingletonInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonController.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonController.instance;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuntimeTestCase 10000000次调用 3ms 。</span></span><br><span class="line"><span class="comment">//测试代码参考 简单懒汉式单例模式 中代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipleInstanceTestCase</span></span><br><span class="line"><span class="comment">//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</span></span><br></pre></td></tr></table></figure><h2 id="枚举实现"><a class="markdownIt-Anchor" href="#枚举实现"></a> 枚举实现</h2><p>最近在看《Effective java 中文版2th》的时候，看到的此种方法，顿时被惊呆。以下为书中原话:</p><pre><code>- since jdk 1.5 。- 只需编写一个包含单个元素的枚举类型即可实现。- 此方法在功能上与公有域方法接近，但是它更加简洁，无偿地提供了序列化机制。- 绝对的防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。- 虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</code></pre><h3 id="code-6"><a class="markdownIt-Anchor" href="#code-6"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="comment">//代码至此已经完事。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单例模式&quot;&gt;&lt;/a&gt; 单例模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;One instance of a class or one value accessible globally in an application.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ensure that only one instance of a class is created.&lt;/li&gt;
&lt;li&gt;Provide a global point of access to the object.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保该唯一实例被创建。&lt;/li&gt;
&lt;li&gt;为外界使用该实例提供一个全局的访问入口。&lt;/li&gt;
&lt;li&gt;对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://www.zhangyebai.com/categories/Design-Pattern/"/>
    
    
      <category term="设计模式" scheme="http://www.zhangyebai.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://www.zhangyebai.com/tags/Design-Pattern/"/>
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 001 - Two Sum (Easy)</title>
    <link href="http://www.zhangyebai.com/2017/02/13/two-sum/"/>
    <id>http://www.zhangyebai.com/2017/02/13/two-sum/</id>
    <published>2017-02-12T21:02:51.000Z</published>
    <updated>2019-02-12T14:44:01.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="descripiton"><a class="markdownIt-Anchor" href="#descripiton"></a> Descripiton</h2><pre><code>Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。</code></pre><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><ul><li>利用map数据结构的Key-Value键值对的存储特点，遍历array数组时，查看当前数组元素value与目标target的差（<strong>target - value</strong>）是否在map的keys中，如果存在说明前面的遍历时找到了第一个value，取出索引并返回当前索引即可;如果没找到，将当前value作为key，当前索引index作为key的value放置进map继续遍历即可。<ul><li>Python中map数据结构为字典（dict）</li><li>适当关注一下c++中std::map和std::vector的相关操作</li><li>以下代码截止到提交日期，均已被LeetCode AC</li></ul></li></ul><h2 id="python-solution"><a class="markdownIt-Anchor" href="#python-solution"></a> <code>Python Solution</code></h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_num</span><span class="params">(nums, target)</span>-&gt;object:</span></span><br><span class="line">nums_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> loop, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line"><span class="keyword">if</span> nums_dict.__contains__(target - value):</span><br><span class="line"><span class="keyword">return</span> [nums_dict[target - value], loop]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nums_dict[value] = loop</span><br><span class="line"></span><br><span class="line"><span class="comment">#TestCase</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num_list = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">    target_num = <span class="number">22</span></span><br><span class="line">    result = Solution().two_num(num_list, target_num)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> result:</span><br><span class="line">            print(<span class="string">'-&gt;'</span>.join([str(index), str(num_list[index])]))</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        print(<span class="string">'no target to find'</span>)</span><br></pre></td></tr></table></figure><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> <code>Java Solution</code></h2><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">Map&amp;ltInteger, Integer&gt; map = <span class="keyword">new</span> HashMap&amp;ltInteger, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>, length = nums.length; index &lt; length; ++index)&#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target - nums[index]))&#123;</span><br><span class="line">    result[<span class="number">0</span>] = map.get(target - nums[index]);</span><br><span class="line">        result[<span class="number">1</span>] = index;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.put(nums[index], index);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-solution"><a class="markdownIt-Anchor" href="#c-solution"></a> <code>C++ Solution</code></h2><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;vector&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;map&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; loop;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> index = <span class="number">0</span>; index &lt; nums.size(); ++index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (loop.find(target - nums.at(index)) != loop.cend())</span><br><span class="line">&#123;</span><br><span class="line">result.push_back(loop.at(target - nums.at(index)));</span><br><span class="line">result.push_back(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">loop.insert(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(nums.at(index), index));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TestCase</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;iostream&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Solution solution;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = solution.twoSum(nums, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = result.begin(); iter != result.end(); ++iter)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> timing = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; timing;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;descripiton&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#descripiton&quot;&gt;&lt;/a&gt; Descripiton&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.

给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。
假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;example&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#example&quot;&gt;&lt;/a&gt; Example&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
      <category term="Python" scheme="http://www.zhangyebai.com/tags/Python/"/>
    
      <category term="C++" scheme="http://www.zhangyebai.com/tags/C/"/>
    
  </entry>
  
</feed>
