<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一码平川</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhangyebai.com/"/>
  <updated>2019-02-12T11:57:32.085Z</updated>
  <id>http://www.zhangyebai.com/</id>
  
  <author>
    <name>张夜白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode - 002 - Add Two Numbers (Medium) [Java,Python,C++]</title>
    <link href="http://www.zhangyebai.com/2017/02/19/add-two-numbers/"/>
    <id>http://www.zhangyebai.com/2017/02/19/add-two-numbers/</id>
    <published>2017-02-19T07:08:44.000Z</published>
    <updated>2019-02-12T11:57:32.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="descripiton"><a class="markdownIt-Anchor" href="#descripiton"></a> Descripiton</h2><pre><code>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in  reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。  这句话什么意思呢？换句话说就是这样：  比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(2) = Node(0)-&gt;Node(4);19 + 91 = 110就表示为Node(9)-&gt;Node(1) + Node(1)-&gt;Node(9) = Node(0)-&gt;Node(1)-&gt;Node(1);因为表示顺序是反着的，所以进位也是反着的。假设这两个数字不包含任何的头结点0，除了数字0本身。</code></pre><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8</code></pre><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><pre><code>通过描述中的大致分析可以看出，需要遍历两个Linked-List中的对应的Node并取数相加，然后生成新Node并添加到result的Link-List中。- 2个Linked-List中对应的Node，如果有一个为null，一个不为null，则结果节点直接使用不为null的Node中的值去构造即可;- 如果两个Node相加需要进位，切记是向后进位，如果有后续Node，计算是需要加上进位;- 如果两个Node相加需要进位，且没有后续Node，则需要添加一个Node，值用进位的数即可;- 以下代码截止到提交日期，均已被LeetCode AC；</code></pre><h2 id="python-solution"><a class="markdownIt-Anchor" href="#python-solution"></a> <code>Python Solution</code></h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><pre><code>#!/usr/bin/env python# _*_ coding:utf-8 _*_#Node定义class ListNode(object):    def __init__(self, x):        self.val = x        self.next = None#LeetCode的命名规范我已经无力吐槽了class Solution(object):    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:        """            :type l1: ListNode            :type l2: ListNode            :rtype: ListNode        """        result = ListNode(0)        step = result        l_hand, r_hand = l1, l2        node_sum = 0        while l_hand is not None or r_hand is not None:            node_sum //= 10            if l_hand is not None:                node_sum += l_hand.val                l_hand = l_hand.next            if r_hand is not None:                node_sum += r_hand.val                r_hand = r_hand.next            step.next = ListNode(node_sum % 10)            step = step.next        if node_sum // 10 > 0:            step.next = ListNode(1)        return result.next#TestCasedef init_node(param)->ListNode:    result_node, temp_node = None, None    for value in param:        if result_node is None:            temp_node = ListNode(value)            result_node = temp_node            continue        temp_node.next = ListNode(value)        temp_node = temp_node.next    return result_nodedef print_node(param_node: ListNode)->None:    temp_node, values = param_node, []    while temp_node is not None:        values.append(str(temp_node.val))        temp_node = temp_node.next    print('[', '->'.join(values), ']', sep=None)if __name__ == '__main__':    l_node = init_node([3, 7])    r_node = init_node([9, 2])    print_node(Solution().add_two_nums(l_node, r_node))</code></pre><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> <code>Java Solution</code></h2><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><pre><code>public class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        ListNode result = new ListNode(0);        ListNode step = result;        ListNode l_hand = l1;        ListNode r_hand = l2;        int node_sum = 0;        for(;l_hand != null || r_hand != null;){            node_sum /= 10;            if (l_hand != null){                node_sum += l_hand.val;                l_hand = l_hand.next;            }            if (r_hand !=null){                node_sum += r_hand.val;                r_hand = r_hand.next;            }            step.next = new ListNode(node_sum % 10);            step = step.next;        }        if (node_sum / 10 > 0){            step.next = new ListNode(1);        }        return result.next;    }    //TestCase    public static void printNode(ListNode node){        while (node != null){            System.out.println(node.val);            node = node.next;        }    }    public static void main(String[] args){        //不要问我这两个数组时哪里来的，没有错误的程序是不会知道的        int[] arr1 = {1,6,6,0,5,8,1,0,7};        int[] arr2 = {8,2,5,7,9,1,0,2,2,1};        printNode(new AddTwoNumbers().addTwoNumbers(initList(arr1), initList(arr2)));    }}class ListNode {     int val;      ListNode next;      ListNode(int x) { val = x; }}</code></pre><h2 id="c-solution"><a class="markdownIt-Anchor" href="#c-solution"></a> <code>C++ Solution</code></h2><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><pre><code>#ifndef NULL#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif#endifstruct ListNode {int val;ListNode *next;ListNode(int x) : val(x), next(NULL) {}};class AddTwoNumbers {public:ListNode* addTwoNumbers(ListNode* l1, ListNode* l2){ListNode head(0);ListNode *step = &head, *l_hand = l1, *r_hand = l2;int node_sum = 0;for (; l_hand || r_hand;) {node_sum /= 10;if (l_hand) {node_sum += l_hand->val;l_hand = l_hand->next;}if (r_hand) {node_sum += r_hand->val;r_hand = r_hand->next;}step->next = new ListNode(node_sum % 10);step = step->next;}if (node_sum / 10 > 0){step->next = new ListNode(1);}return head.next;}};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;descripiton&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#descripiton&quot;&gt;&lt;/a&gt; Descripiton&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in  
reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

给定两个表示非负整数的链表.链表里面的数字是倒叙存储的，链表的每个Node包含一个单独的数字（个位数）。将这两个数相加，并用一个链表返回。  
这句话什么意思呢？换句话说就是这样：  
	比如两个正常的非负整数，19 + 21 = 40用上述链表就表示为Node(9)-&amp;gt;Node(1) + Node(1)-&amp;gt;Node(2) = Node(0)-&amp;gt;Node(4);
	19 + 91 = 110就表示为Node(9)-&amp;gt;Node(1) + Node(1)-&amp;gt;Node(9) = Node(0)-&amp;gt;Node(1)-&amp;gt;Node(1);
	因为表示顺序是反着的，所以进位也是反着的。
假设这两个数字不包含任何的头结点0，除了数字0本身。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;example&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#example&quot;&gt;&lt;/a&gt; Example&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
Output: 7 -&amp;gt; 0 -&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="Python" scheme="http://www.zhangyebai.com/tags/Python/"/>
    
      <category term="C++" scheme="http://www.zhangyebai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Singleton - 单例模式 - Java</title>
    <link href="http://www.zhangyebai.com/2017/02/13/Singleton/"/>
    <id>http://www.zhangyebai.com/2017/02/13/Singleton/</id>
    <published>2017-02-13T15:48:30.000Z</published>
    <updated>2019-02-12T07:44:10.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h1><ul><li><p>One instance of a class or one value accessible globally in an application.</p><ul><li>Ensure that only one instance of a class is created.</li><li>Provide a global point of access to the object.</li></ul></li><li><p>在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点:</p><ul><li>确保该唯一实例被创建。</li><li>为外界使用该实例提供一个全局的访问入口。</li><li>对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。</li></ul></li></ul><a id="more"></a><h2 id="简单懒汉式单例模式"><a class="markdownIt-Anchor" href="#简单懒汉式单例模式"></a> 简单懒汉式单例模式</h2><pre><code>- 简单 * 3，但是致命缺点是线程不安全。- 懒汉式:在Singleton被ClassLoader加载时并不实例化instance，只有在需要时(即调用getInstance方法时)才会触发实例化。- getInstance，newInstance在命名规范上的区别是分别对应单例和多例!</code></pre><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><pre><code>public class Singleton implements java.io.Serializable {private static Singleton instance;private Singleton(){}public static Singleton getSingletonInstance(){if (instance == null){instance = new Singleton();}return instance;}private Object readResolve(){return instance;}}//RuntimeTestCase 10000000次 3mspublic static void testRuntime(){long timestart = System.currentTimeMillis();for (int index = 0, loop = 10000000; index < loop; ++index){Singleton singletonThread1 = Singleton.getSingletonInstance();}}long timeend = System.currentTimeMillis();System.out.println(timeend - timestart);}//MultipleInstanceTestCaseclass MultipleTest implements Runnable{public Map<singleton, integer=""> hMap = new Hashtable<>();@Overridepublic void run() {Singleton singleton = Singleton.getSingletonInstance();hMap.put(singleton, 0);}}/*开启了100000个线程测试，并未发现有多个实例的现象，但是此种做法确实是存在多例的风险，原因在于当两个线程同时调用  getSingletonInstance()且instance都为null时，两个线程可能会同时执行instance = new Singleton();*/</singleton,></code></pre><h2 id="线程安全懒汉式单例模式"><a class="markdownIt-Anchor" href="#线程安全懒汉式单例模式"></a> 线程安全懒汉式单例模式</h2><pre><code>- 通过对全局入口方法加同步来解决线程安全的问题。- 带来的后果是资源的开销是非常大的，因为初始化完instance后不再需要synchronized- 毕竟线程安全了。</code></pre><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><pre><code>public class Singleton implements java.io.Serializable {private static Singleton instance;private Singleton(){}public static synchroized Singleton getSingletonInstance(){if (instance == null){instance = new Singleton();}return instance;}private Object readResolve(){return instance;}}//RuntimeTestCase 10000000次调用 56ms （简单懒汉式单例模式中为3ms）//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</code></pre><h2 id="改进效率版懒汉式单例模式"><a class="markdownIt-Anchor" href="#改进效率版懒汉式单例模式"></a> 改进效率版懒汉式单例模式</h2><pre><code>- synchroized 同步方法的资源开销是很大的。- 改进点在于用synchronized同步实例化代码块，这样的好处是一旦实例化完成，以后的调用不会再触碰到synchronized。</code></pre><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><pre><code>public class Singleton  implements java.io.Serializable{private volatile static Singleton instance;private Singleton(){}public static  Singleton getSingletonInstance(){if (instance == null){synchroized(Singleton.class){if(instance == null){instance = new Singleton();}}}return instance;}private Object readResolve(){return instance;}}//RuntimeTestCase 10000000次调用 3ms 理论上来说应该于 简单懒汉式单例模式 中的实现效率持平。//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</code></pre><h2 id="饿汉式单例模式"><a class="markdownIt-Anchor" href="#饿汉式单例模式"></a> 饿汉式单例模式</h2><pre><code>- 触发ClassLoader加载该类时实例化。- 与懒汉式的区别是:主动实例化。</code></pre><h3 id="code-4"><a class="markdownIt-Anchor" href="#code-4"></a> code</h3><pre><code>public class Singleton  implements java.io.Serializable{private static Singleton instance = new Singleton();private Singleton(){}public static  Singleton getSingletonInstance(){return instance;}private Object readResolve(){return instance;}}//另一种写法是通过静态代码块实例化public class Singleton  implements java.io.Serializable{private static Singleton instance;static{instance = new Singleton();}private Singleton(){}public static  Singleton getSingletonInstance(){return instance;}private Object readResolve(){return instance;}}//RuntimeTestCase 10000000次调用 2ms。//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</code></pre><h2 id="静态内部类实现单例"><a class="markdownIt-Anchor" href="#静态内部类实现单例"></a> 静态内部类实现单例</h2><pre><code>- 实现延迟实例化。- 线程安全。- 推荐使用。</code></pre><h3 id="code-5"><a class="markdownIt-Anchor" href="#code-5"></a> code</h3><pre><code>public class Singleton  implements java.io.Serializable{private static class SingletonController{private static Singleton instance = new Singleton();}public static  Singleton getSingletonInstance(){return SingletonController.instance;}private Object readResolve(){return SingletonController.instance;;}}//RuntimeTestCase 10000000次调用 3ms 。//测试代码参考 简单懒汉式单例模式 中代码//MultipleInstanceTestCase//参考 简单懒汉式单例模式 中代码，笔者并未测出，理论分析并无多例产生的可能性。</code></pre><h2 id="枚举实现"><a class="markdownIt-Anchor" href="#枚举实现"></a> 枚举实现</h2><p>最近在看《Effective java 中文版2th》的时候，看到的此种方法，顿时被惊呆。以下为书中原话:</p><pre><code>- since jdk 1.5 。- 只需编写一个包含单个元素的枚举类型即可实现。- 此方法在功能上与公有域方法接近，但是它更加简洁，无偿地提供了序列化机制。- 绝对的防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。- 虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</code></pre><h3 id="code-6"><a class="markdownIt-Anchor" href="#code-6"></a> code</h3><pre><code>public enum Singleton{INSTANCE;//代码至此已经完事。}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单例模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单例模式&quot;&gt;&lt;/a&gt; 单例模式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;One instance of a class or one value accessible globally in an application.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ensure that only one instance of a class is created.&lt;/li&gt;
&lt;li&gt;Provide a global point of access to the object.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在一个应用程序中，一个类仅有一个实例供外界所用。它所代表的含义有两点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保该唯一实例被创建。&lt;/li&gt;
&lt;li&gt;为外界使用该实例提供一个全局的访问入口。&lt;/li&gt;
&lt;li&gt;对于实现Serializable接口可序列化的单例类，需要实现Object readResolve(){}解决序列化、反序列化过程中造成的多例现象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://www.zhangyebai.com/categories/Design-Pattern/"/>
    
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://www.zhangyebai.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://www.zhangyebai.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 001 - Two Sum (Easy) [Java,Python,C++]</title>
    <link href="http://www.zhangyebai.com/2017/02/13/two-sum/"/>
    <id>http://www.zhangyebai.com/2017/02/13/two-sum/</id>
    <published>2017-02-12T21:02:51.000Z</published>
    <updated>2019-02-12T07:44:10.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="descripiton"><a class="markdownIt-Anchor" href="#descripiton"></a> Descripiton</h1><pre><code>Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。</code></pre><h1 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h1><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><h1 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h1><ul><li>利用map数据结构的Key-Value键值对的存储特点，遍历array数组时，查看当前数组元素value与目标target的差（<strong>target - value</strong>）是否在map的keys中，如果存在说明前面的遍历时找到了第一个value，取出索引并返回当前索引即可;如果没找到，将当前value作为key，当前索引index作为key的value放置进map继续遍历即可。<ul><li>Python中map数据结构为字典（dict）</li><li>适当关注一下c++中std::map和std::vector的相关操作</li><li>以下代码截止到提交日期，均已被LeetCode AC</li></ul></li></ul><a id="more"></a><h2 id="python-solution"><a class="markdownIt-Anchor" href="#python-solution"></a> <code>Python Solution</code></h2><h3 id="code"><a class="markdownIt-Anchor" href="#code"></a> code</h3><pre><code>#!/usr/bin/env python# _*_ coding:utf-8 _*_class Solution(object):def two_num(nums, target)->object:nums_dict = {}for loop, value in enumerate(nums):if nums_dict.__contains__(target - value):return [nums_dict[target - value], loop]else:nums_dict[value] = loop#TestCaseif __name__ == '__main__':    num_list = [2, 7, 11, 15]    target_num = 22    result = Solution().two_num(num_list, target_num)    try:        for index in result:            print('->'.join([str(index), str(num_list[index])]))    except TypeError:        print('no target to find')</code></pre><h2 id="java-solution"><a class="markdownIt-Anchor" href="#java-solution"></a> <code>Java Solution</code></h2><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> code</h3><pre><code>public class Solution{public int[] twoSum(int[] nums, int target) {int[] result = new int[2];Map&ltInteger, Integer> map = new HashMap&ltInteger, Integer>();for(int index = 0, length = nums.length; index < length; ++index){if (map.containsKey(target - nums[index])){    result[0] = map.get(target - nums[index]);        result[1] = index;        }else{        map.put(nums[index], index);        }}return result;}}</code></pre><h2 id="c-solution"><a class="markdownIt-Anchor" href="#c-solution"></a> <code>C++ Solution</code></h2><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> code</h3><pre><code>#include &lt;vector>#include &lt;map>class Solution {public:std::vector<int> twoSum(std::vector<int>& nums, int target) {std::vector<int> result;std::map<int, int=""> loop;for (std::size_t index = 0; index < nums.size(); ++index){if (loop.find(target - nums.at(index)) != loop.cend()){result.push_back(loop.at(target - nums.at(index)));result.push_back(index);}else{loop.insert(std::map<int, int="">::value_type(nums.at(index), index));}}return result;}};//TestCase#include &lt;iostream>int main(){Solution solution;std::vector<int> nums = { 2, 7, 11, 15 };std::vector<int> result = solution.twoSum(nums, 9);for(std::vector<int>::iterator iter = result.begin(); iter != result.end(); ++iter)std::cout << *iter << std::endl;int timing = 0;std::cin >> timing;    return 0;}</int></int></int></int,></int,></int></int></int></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;descripiton&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#descripiton&quot;&gt;&lt;/a&gt; Descripiton&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.

给定一个整形数组array，给定一个整形目标数target，返回array数组中2个相加等于目标数target的元素索引index。
假设每次输入的数组都有为恰好只有唯一解，而且不能使用array数组中的元素超过一次。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;example&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#example&quot;&gt;&lt;/a&gt; Example&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;solution&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#solution&quot;&gt;&lt;/a&gt; Solution&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;利用map数据结构的Key-Value键值对的存储特点，遍历array数组时，查看当前数组元素value与目标target的差（&lt;strong&gt;target - value&lt;/strong&gt;）是否在map的keys中，如果存在说明前面的遍历时找到了第一个value，取出索引并返回当前索引即可;如果没找到，将当前value作为key，当前索引index作为key的value放置进map继续遍历即可。
&lt;ul&gt;
&lt;li&gt;Python中map数据结构为字典（dict）&lt;/li&gt;
&lt;li&gt;适当关注一下c++中std::map和std::vector的相关操作&lt;/li&gt;
&lt;li&gt;以下代码截止到提交日期，均已被LeetCode AC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://www.zhangyebai.com/categories/LeetCode/"/>
    
    
      <category term="leetcode" scheme="http://www.zhangyebai.com/tags/leetcode/"/>
    
      <category term="Java" scheme="http://www.zhangyebai.com/tags/Java/"/>
    
      <category term="Python" scheme="http://www.zhangyebai.com/tags/Python/"/>
    
      <category term="C++" scheme="http://www.zhangyebai.com/tags/C/"/>
    
  </entry>
  
</feed>
